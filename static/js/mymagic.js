/*! MagicEye.js (https://github.com/peeinears/MagicEye.js)
 *
 *  MIT License (http://www.opensource.org/licenses/mit-license.html)
 *  Copyright (c) 2014 Ian Pearce
 */

!(function(){
  'use strict';

  var MagicEye = {

    render: function (opts) {
      opts = opts || {};

      var defaultOptions = {
        width: null,
        height: null,
        depthMap: null,
        depthMapper: new MagicEye.DepthMapper(),
        imageType: 'png',
        mul: 2,
        s: 72,
        rows: [0,-1],
        colors: [
          [0, 0, 0, 0],
          [0, 0, 0, 255]
        ]
      };

      for (var property in defaultOptions) {
        if( ! opts.hasOwnProperty(property) ) opts[property] = defaultOptions[property];
      }

      var element, width, height, depthMap, pixelData, i;

      // find and set element
      if (opts.el) {
        element = (typeof opts.el === 'string' ? document.getElementById(opts.el) : opts.el);
        if (!element || !element.tagName) throw('MagicEye: Could not find element: ' + opts.el);
      }

      // use element's height and width unless height and width is provided
      width = opts.width  || element.width ;
      if (!width) throw('MagicEye: width not set and could not be inferred from element: ' + opts.el);
      height = opts.height || element.height;
      if (!height) throw('MagicEye: height not set and could not be inferred from element: ' + opts.el);

      // use depthMap if provided, otherwise use depthMap generated by given depthMapper
      if (opts.depthMap) {
        depthMap = opts.depthMap;
      } else if (opts.depthMapper) {
        depthMap = opts.depthMapper.generate(width, height );
      } else throw('MagicEye: no depthMap or depthMapper opts given');

      // convert hex colors to RGBa
      for (i = 0; i < opts.colors.length; i++) {
        if (typeof opts.colors[i] === 'string') {
          opts.colors[i] = this.helpers.hexToRGBa(opts.colors[i]);
        }
      }
	  const t0 = performance.now();
      pixelData = this.generatePixelData({
        width: width,
        height: height,
        depthMap: depthMap,
        mul: opts.mul,
        colors: opts.colors,
        s: opts.s,
        rows: opts.rows
      });
      const t1 = performance.now();
      console.log(`Gen Pixel Data took ${t1 - t0} milliseconds.`);
      

      switch (element.tagName) {
      case 'CANVAS':
        this.renderToCanvas(element, pixelData, width, height, opts.rows);
        break;

      case 'IMG':
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        this.renderToCanvas(canvas, pixelData, width, height, opts.rows);
        element.src = canvas.toDataURL('image/' + (opts.imageType || 'png'));
        break;

      default:
        throw('MagicEye: el must be either a <canvas> or an <img>');
      }
      const t2 = performance.now();
      console.log(`Render To Canvas took ${t2 - t1} milliseconds.`);

      return this;
    },

    renderToCanvas: function (canvas, pixelData, width, height, rows) {
      var context = canvas.getContext("2d");
      if (rows[1] > -1){
      	height = (rows[1] - rows[0]);
      	pixelData = pixelData.slice(rows[0]*width*4,rows[1]*width*4);
      }
      var imageData = context.createImageData(width, height);
      
      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, rows[0]);
    },

    generatePixelData: function (opts) {

      /*
       * This algorithm was published in a paper authored by by Harold W.
       * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
       * translated from the C code that was featured in the article.
       * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
       */
		var fronts = [];
      var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
          width = opts.width * opts.mul,
          height = opts.height * opts.mul,
          mul = opts.mul,
          s = opts.s,
          rows = opts.rows,
          depthMapSmall = opts.depthMap,
          numColors = opts.colors.length,
          same, // points to a pixel to the right
          dpi = 72, // assuming output of 72 dots per inch
          eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
          mu = (1 / 3), // depth of field (fraction of viewing distance)
          pixels = new Uint8ClampedArray(width * height * 4),
          pixelsOut = new Uint8ClampedArray(width * height * 4 / mul / mul);
	  const t0 = performance.now();
	  var yMin = 0;
	  var yMax = height;
	  if (rows[1] > -1){
	  	yMin = rows[0]*mul;
	  	yMax = rows[1]*mul;
	  }
	  
	  var depthMap = [];
	  for (y = 0; y < yMin; y++) {
        depthMap.push([]);
      }
	  for (y = yMin; y < yMax; y++) {
        depthMap.push([]);
        for (x = 0; x < width; x++) {
        	var d = depthMapSmall[Math.floor(y/mul)][Math.floor(x/mul)];
        	depthMap[y].push(d);
        }
      }
      const t1 = performance.now();
      console.log(`First part took ${t1 - t0} milliseconds.`);
      // for each row
      
      
	 
	  const t2 = performance.now();
	  console.log(`Second part took ${t2 - t1} milliseconds.`);
      for (y = yMin; y < yMax; y++) {
      	var ym = [];
      	ym.push(this.helpers.mulberry(y));
      	ym.push(this.helpers.mulberry(y + height));
      	ym.push(this.helpers.mulberry(y + 2 * height));
      	ym.push(this.helpers.mulberry(y + 3 * height));
        var m = 0;
        var colorsFG = [];
		  for (var i=0;i<s * 2;i++){
			var c = [0,0,0,255];
			c[1] = this.helpers.mulberry(ym[0] + i) % 256;
			c[2] = this.helpers.mulberry(ym[1] + i) % 256;
			colorsFG.push(c);
		  }
		var colorsBG = [];
		  for (var i=0;i<180;i++){
			var c = [0,0,0,255];
			c[1] = this.helpers.mulberry(ym[2] + i) % 256;
			c[2] = this.helpers.mulberry(ym[3] + i) % 256;
			colorsBG.push(c);
		  }
		for (x = 0; x < width; x++) {
			var pixelOffset = (y * width * 4) + (x * 4);
			for (var i=0;i<4;i++){
				pixels[pixelOffset + i]=0;
			}
			pixels[pixelOffset + 3]=255;
		}
		
        for (x = 0; x < width; x++) {
		  var pixelOffset = (y * width * 4) + (x * 4);
          z = depthMap[y][x];
		  if (z > 0.5){
		  	var left = x - s;
		  	var right = x + s;
		  	var leftOffset = (y * width * 4) + (left * 4);
		  	var rightOffset = (y * width * 4) + (right * 4);
		  	pixels[leftOffset + 0] = 20;
			pixels[rightOffset + 0] = 20;
		  	for (var i=1;i<3;i++){
				pixels[leftOffset + i] = colorsFG[x % (s*2)][i];
				pixels[rightOffset + i] = colorsFG[x % (s*2)][i];
		  	}
		  	m++;
		  }
        }
        var maxM = m;
        var m =0;
        //console.log(maxM);
        for (x = 0; x < width; x++) {
		  var pixelOffset = (y * width * 4) + (x * 4);
          z = depthMap[y][x];
		  if (z > 0.5){
		  	if (m >= maxM - (s*2)){
				var right = x + s;
				var rightOffset = (y * width * 4) + (right * 4);
				for (var i=1;i<3;i++){
					for (var ii=1;right + ii*180 < width;ii++){
						pixels[rightOffset + ii*720 + i] = colorsFG[x % (s*2)][i];
					}
				}
		  	}
		  	else if (m >= maxM - 180){
				var right = x + s;
				var rightOffset = (y * width * 4) + (right * 4);
				for (var i=1;i<3;i++){
					for (var ii=1;right + ii*180 < width;ii++){
						if (ii==1 && i == 2){
							pixels[rightOffset + ii*720 + i] = colorsFG[x % (s*2)][i];
						}
						else {
							pixels[rightOffset + ii*720 + i] = colorsBG[(x % 180)][i];
						
						}
					}
				}
		  	}
		  	if (m < (s*2)){
				var left = x - s;
				var leftOffset = (y * width * 4) + (left * 4);
				for (var i=1;i<3;i++){
					pixels[leftOffset + i] = colorsFG[x % (s*2)][i];
					for (var ii=-1;left + ii*180 >= 0;ii--){
						pixels[leftOffset + ii*720 + i] = colorsFG[x % (s*2)][i];
					}
				}
		  	}
		  	else if (m < 180){
				var left = x - s;
				var leftOffset = (y * width * 4) + (left * 4);
				for (var i=1;i<3;i++){
					pixels[leftOffset + i] = colorsFG[x % (s*2)][i];
					for (var ii=-1;left + ii*180 >= 0;ii--){
						if (ii == -1 && i == 2){
							pixels[leftOffset + ii*720 + i] = colorsFG[x % (s*2)][i];
						}
						else {
							pixels[leftOffset + ii*720 + i] = colorsBG[(x % 180)][i];
						}
						
					}
				}
		  	}
		  	m++;
		  }
        }
        
        for (x = 0; x < width; x++) {
		  var pixelOffset = (y * width * 4) + (x * 4);
          
		  if (pixels[pixelOffset + 0] == 0 && pixels[pixelOffset + 1] == 0 && pixels[pixelOffset + 2] == 0){
		  	
		  	for (var i=0;i<4;i++){
				pixels[pixelOffset + i] = colorsBG[(x % 180)][i];
				
		  	}
		  	for (var ii=1;x + ii*180 < width;ii++){
				if (pixels[pixelOffset +ii*720 + 0] == 0 && pixels[pixelOffset+ii*720 + 1] == 0 && pixels[pixelOffset+ii*720 + 2] == 0) {
					for (var i=0;i<4;i++){
						pixels[pixelOffset + ii*720 + i] = colorsBG[(x % 180)][i];
					}
				}
			}
		  	m++;
		  }
		  
          
        }
		
       
      }
      const t3 = performance.now();
      console.log(`First Loop took ${t3 - t2} milliseconds.`);
      for (y = yMin/mul; y < yMax/mul ; y++) {
        
        for (x = 0; x < width/mul; x++) {
        	var pixelOffset = (y * width / mul * 4) + (x * 4);
        	var pixelOffsetBig = (y * mul * width * 4) + (x * mul * 4);
        	pixelsOut[pixelOffset] = 0;
        	pixelsOut[pixelOffset+3] = 255;
        	for (var i=1;i<3;i++){
        		var v = 0;
        		for (var ii=0;ii<mul && y*mul+ii<height;ii++){
        			for (var iii=0;iii<mul && x*mul+iii<width;iii++){
        				if (((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i < width * height * 4){
        					v += pixels[((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i];
        					
        				}
        			}
        		}
        		v /= mul;
        		v /= mul;
        		
        		pixelsOut[pixelOffset+i] = Math.floor(v);
        	}
        	
			
        	
        }
      }
	  const t4 = performance.now();
      console.log(`Second Loop took ${t4 - t3} milliseconds.`);
      return pixelsOut;
    },

    helpers: {

      // http://stackoverflow.com/a/5624139
      hexToRGBa: function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16),
          255
        ] : null;
      },
       mulberry: function (a) {
			
			  var t = a += 0x6D2B79F5;
			  t = Math.imul(t ^ t >>> 15, t | 1);
			  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
			  return (t ^ t >>> 14) >>> 0;
			
	  }
    }

  };


// -- DepthMapper --

  var DepthMapper = function () {};

  DepthMapper.prototype.autoResize = true;

  DepthMapper.prototype.make = function (width, height) {
    // !!! Overwrite this method
    return [[0]];
  };

  DepthMapper.prototype.generate = function (width, height) {
    if (this.autoResize) return this.resize(this.make(width, height), width, height);
    else return this.make(width, height);
  };

  DepthMapper.prototype.resize = function (origDepthMap, width, height) {
    var origDepthMapY, x, y,
        resizedDepthMap = [],
        origDepthMapHeight = origDepthMap.length,
        origDepthMapWidth = origDepthMap[0].length;

    if (origDepthMapWidth === width && origDepthMapHeight === height) {
      return origDepthMap;
    }

    for (y = 0; y < height; y++) {
      resizedDepthMap[y] = new Float32Array(width);
      origDepthMapY = Math.floor(y * origDepthMapHeight / height);
      for (x = 0; x < width; x++) {
        resizedDepthMap[y][x] = origDepthMap[origDepthMapY][Math.floor(x * origDepthMapWidth / width)];
      }
    }

    return resizedDepthMap;
  };

  // Credit: backbone, underscore
  DepthMapper.extend = function (protoProps) {
    var parent = this;
    var child;

    var extend = function(obj) {
      if (!obj || (typeof obj != 'function' && typeof obj != 'object')) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  MagicEye.DepthMapper = DepthMapper;


  this.MagicEye = MagicEye;

}).call(this);
