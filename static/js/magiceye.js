/*! MagicEye.js (https://github.com/peeinears/MagicEye.js)
 *
 *  MIT License (http://www.opensource.org/licenses/mit-license.html)
 *  Copyright (c) 2014 Ian Pearce
 */

!(function(){
  'use strict';

  var MagicEye = {

    render: function (opts) {
      opts = opts || {};

      var defaultOptions = {
        width: null,
        height: null,
        depthMap: null,
        depthMapper: new MagicEye.DepthMapper(),
        imageType: 'png',
        mul: 2,
        colors: [
          [0, 0, 0, 0],
          [0, 0, 0, 255]
        ]
      };

      for (var property in defaultOptions) {
        if( ! opts.hasOwnProperty(property) ) opts[property] = defaultOptions[property];
      }

      var element, width, height, depthMap, pixelData, i;

      // find and set element
      if (opts.el) {
        element = (typeof opts.el === 'string' ? document.getElementById(opts.el) : opts.el);
        if (!element || !element.tagName) throw('MagicEye: Could not find element: ' + opts.el);
      }

      // use element's height and width unless height and width is provided
      width = opts.width  || element.width ;
      if (!width) throw('MagicEye: width not set and could not be inferred from element: ' + opts.el);
      height = opts.height || element.height;
      if (!height) throw('MagicEye: height not set and could not be inferred from element: ' + opts.el);

      // use depthMap if provided, otherwise use depthMap generated by given depthMapper
      if (opts.depthMap) {
        depthMap = opts.depthMap;
      } else if (opts.depthMapper) {
        depthMap = opts.depthMapper.generate(width, height );
      } else throw('MagicEye: no depthMap or depthMapper opts given');

      // convert hex colors to RGBa
      for (i = 0; i < opts.colors.length; i++) {
        if (typeof opts.colors[i] === 'string') {
          opts.colors[i] = this.helpers.hexToRGBa(opts.colors[i]);
        }
      }

      pixelData = this.generatePixelData({
        width: width,
        height: height,
        depthMap: depthMap,
        mul: opts.mul,
        colors: opts.colors
      });
      
      

      switch (element.tagName) {
      case 'CANVAS':
        this.renderToCanvas(element, pixelData, width, height);
        break;

      case 'IMG':
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        this.renderToCanvas(canvas, pixelData, width, height);
        element.src = canvas.toDataURL('image/' + (opts.imageType || 'png'));
        break;

      default:
        throw('MagicEye: el must be either a <canvas> or an <img>');
      }

      return this;
    },

    renderToCanvas: function (canvas, pixelData, width, height) {
    	console.log(pixelData.length);
      var context = canvas.getContext("2d"),
          imageData = context.createImageData(width, height);
      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, 0);
    },

    generatePixelData: function (opts) {

      /*
       * This algorithm was published in a paper authored by by Harold W.
       * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
       * translated from the C code that was featured in the article.
       * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
       */
		var fronts = [];
      var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
          width = opts.width * opts.mul,
          height = opts.height * opts.mul,
          mul = opts.mul,
          depthMapSmall = opts.depthMap,
          numColors = opts.colors.length,
          same, // points to a pixel to the right
          dpi = 72, // assuming output of 72 dots per inch
          eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
          mu = (1 / 3), // depth of field (fraction of viewing distance)
          pixels = new Uint8ClampedArray(width * height * 4),
          pixelsOut = new Uint8ClampedArray(width * height * 4 / mul / mul);
	  
	  var depthMap = [];
	  for (y = 0; y < height; y++) {
        depthMap.push([]);
        for (x = 0; x < width; x++) {
        	var d = depthMapSmall[Math.floor(y/mul)][Math.floor(x/mul)];
        	depthMap[y].push(d);
        }
      }
      
      // for each row
      var depth0 = {};
      var distance1 = {};
      for (y = 0; y < height; y++) {
      	depth0[y]={};
      	distance1[y]={};
      	for (x = 0; x < width; x++) {
      		depth0[y][x]=0;
      		distance1[y][x]=-1;
      	}
      }
      
      for (y = 0; y < height; y++) {
        // max image width (for Uint16Array) is 65536
        same = new Uint16Array(width); // points to a pixel to the right

        for (x = 0; x < width; x++) {
          same[x] = x; // each pixel is initially linked with itself
        }

        // for each column
        var fs = {};
        for (x = 0; x < width; x++) {
        	fs[x] = 0;
        }
        for (x = 0; x < width; x++) {

          z = depthMap[y][x];
		  
          // stereo separation corresponding to z
          sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

          // x-values corresponding to left and right eyes
          left = Math.round(x - ((sep + (sep & y & 1)) / 2));
          right = left + sep;
          var frontPoint = [y,left,right];
		  
          if (0 <= left && right < width) {

            // remove hidden surfaces
            t = 1;
            do {
              zt = z + (2 * (2 - (mu * z)) * t / (mu * eyeSep));
              visible = (depthMap[y][x-t] < zt) && (depthMap[y][x+t] < zt); // false if obscured
              t++;
            } while (visible && zt < 1);

            if (visible) {
              // record that left and right pixels are the same
              for (k = same[left]; k !== left && k !== right; k = same[left]) {
                if (k < right) {
                  left = k;
                } else {
                  left = right;
                  right = k;
                }
              }
              same[left] = right;
              frontPoint = [y,x,left,right];
              
            }
            if (z > 0.5){
		  		fronts.push(frontPoint);
		  		fs[frontPoint[2]]++;
              	fs[frontPoint[3]]++;
              	depth0[y][frontPoint[2]]=1;
              	depth0[y][frontPoint[3]]=1;
		  	}
          }
          
          
        }
		var chain = {};
		var chainStart = {};
		for (x = (width - 1); x >= 0; x--) {
			if (same[x] == x){
				chain[x] = [x];
				chainStart[x] = x;
			}
			else {
				if (chain[same[x]]){
        			chain[same[x]].push(x);
        			chainStart[x] = same[x];
        		}
        		else {
        			chain[chainStart[same[x]]].push(x);
        			chainStart[x] = chainStart[same[x]];
        			//console.log(x,same[x]);
        		}
				
			}
        }
        for (x = (width - 1); x >= 0; x--) {
        	var myChain = chain[chainStart[x]];
        	var lD = 0;
        	var rD = 0;
        	var found = false;
        	var maxD = 0;
        	var distanceToFront = -1;
        	for (var i=0;i<myChain.length;i++){
        		if (found){
        			rD++;
        			if (depth0[y][myChain[i]] > 0){
        				if (rD < lD){
        					distanceToFront = rD;
        				}
        				break;
        			}
        		}
        		else if (myChain[i] == x){
        			if (depth0[y][myChain[i]] > 0){
        				distanceToFront = 0;
        				break;
        			}
        			else {
        				lD = i - maxD;
        				distanceToFront = lD;
        			}
        			found = true;
        		}
        		else {
        			if (depth0[y][myChain[i]] > 0){
        				maxD = i;
        			}
        			
        		}
        	}
        	distance1[y][x]=distanceToFront;
        	
			
        }
        
        for (x = (width - 1); x >= 0; x--) {
          pixelOffset = (y * width * 4) + (x * 4);
          
          if (same[x] === x) {
            // set random color
            if (colorChain[y][x]){
            	rgba = [0,0,0,0];
            	rgba[0] = colorChain[y][x][0];
            	if (fs[x] > 0){
            		rgba[1] = Math.floor(colorChain[y][x][1]*4/5+Math.random()*255/5);
            		rgba[2] = Math.floor(colorChain[y][x][2]*4/5+Math.random()*255/5);
            	}
            	else {
            		rgba[1] = Math.floor(colorChain[y][x][1]*1/2+Math.random()*255/2);
            		rgba[2] = Math.floor(colorChain[y][x][2]*1/2+Math.random()*255/2);
            	}
            	rgba[3] = colorChain[y][x][3];
            }
            else {
				var pF = 0;
				var tx = 0;
				for (var i=0;i<chain[x].length;i++){
					pF += fs[chain[x][i]];
					tx += chain[x][i];
				}
				var ax = tx/chain[x].length;
				//if (y = 150){
				//	console.log(x,ax);
				//}
				rgba = opts.colors[Math.floor(Math.random() * numColors)];
			
				rgba[0] = 0;
				var axm = (ax % 100);
				var yr = (y % 100)/100;
				var yi = axm - 50;
				var xMin = 0;
				if (yi < 0){
					xMin = -1*yi;
				}
				var xMax = 100;
				if (yi > 0){
					xMax = 100 - yi;
				}
				var xx = yr*(xMax-xMin)+xMin;
				var yy = 1*(xx)+yi;
				
				if (y == 150){
					//console.log(x,y,ax,yi,xMin,xMax,xx,yr,yy);
				}
				var yr =  (yy %100)/200 + Math.random()*1/2;
				var xr =  (xx %100)/200 + Math.random()*1/2;
				var value1 = Math.abs(noise.perlin2(xr,yr));
    			
    			value1 *= 2560/2;
    			if (value1 > 255){value1 = 255;}
    			
    			var yr =  (y %100)/800 + Math.random()*7/8;
				var xr =  (ax %100)/1600 + Math.random()*15/16;
				var value2 = Math.abs(noise.perlin2(xr, yr));
    			
    			value2 *= 2560/2;
    			if (value2 > 255){value2 = 255;}
    			
				
				
				rgba[1] = Math.floor(Math.random() * 255);
				rgba[2] = Math.floor(Math.random() * 255);
				rgba[3] = 255;
				colorChain[y][x] = [0,0,0,0];
				colorChain[y][x][0] = rgba[0];
				colorChain[y][x][1] = rgba[1];
				colorChain[y][x][2] = rgba[2];
				colorChain[y][x][3] = rgba[3];
            }
            if (rgba[0] > 255){rgba[0] = 255;}
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = rgba[i];
            }
            
            
          } else {
            // constrained pixel, obey constraint
            pixelOffset = (y * width * 4) + (x * 4);
				
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = pixels[(y * width * 4) + (same[x] * 4) + i];
            }
            var myChain = chain[chainStart[x]];
            pixels[pixelOffset + 0] = 0;
            /*for (var i=1;i<myChain.length;i++){
            	if (myChain[i] == x){
            		if (myChain[i] - myChain[i-1] < 90){
            			pixels[pixelOffset + 0] = 100;
            		}
            		break;
            	}
            }*/
            
            if (fs[x] > 0){
				pixels[pixelOffset + 0] = 0;
			}
            
            //pixels[pixelOffset + 1] = 255 - pixels[pixelOffset + 1];
            //pixels[pixelOffset + 2] = 255 - pixels[pixelOffset + 2];
            
          }
          
          //pixels[pixelOffset + 0] = x * 128 / 800 ;
        }
        /*var minSep = Math.round((1 - (mu * 1)) * eyeSep / (2 - (mu * 1)));
        var maxSep = Math.round((1 - (mu * 0)) * eyeSep / (2 - (mu * 0)));
        for (var x = 50; x < width-50; x++) {
        	
        	var pDepth = 0;
        	for (var sep = minSep; sep< maxSep+1;sep++){
        	  
			  left = Math.round(x - ((sep + (sep & y & 1)) / 2));
			  right = left + sep;
			  var d = 0;
			  d += Math.pow(pixels[y * width * 4 + left * 4 + 1]-pixels[y * width * 4 + right * 4 + 1],2);
			  d += Math.pow(pixels[y * width * 4 + left * 4 + 2]-pixels[y * width * 4 + right * 4 + 2],2);
			  if (d < 1000){
			  	pMap[y][x] = sep;
			  	break;
			  }
        	}
        	if (y == 150 && pMap[y][x] < 90){
        		console.log(depthMap[y][x],pMap[y][x])
        	}
        }*/
       
      }
      for (y = 0; y < height/mul ; y++) {
        
        for (x = 0; x < width/mul; x++) {
        	var pixelOffset = (y * width / mul * 4) + (x * 4);
        	var pixelOffsetBig = (y * mul * width * 4) + (x * mul * 4);
        	pixelsOut[pixelOffset] = 0;
        	pixelsOut[pixelOffset+3] = 255;
        	for (var i=1;i<3;i++){
        		var v = 0;
        		var d = 0;
        		for (var ii=0;ii<mul && y*mul+ii<height;ii++){
        			for (var iii=0;iii<mul && x*mul+iii<width;iii++){
        				if (((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i < width * height * 4){
        					v += pixels[((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i];
        					d += depth0[y * mul + ii][x * mul + iii];
        				}
        			}
        		}
        		v /= mul;
        		v /= mul;
        		if (d >= 0){
        			var vv = 0;
        			for (var ii=0;ii<2*mul && y*mul+ii<height;ii++){
						for (var iii=0;iii<2*mul && x*mul+iii<width;iii++){
							if (((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i < width * height * 4){
								vv += pixels[((y * mul + ii) * width * 4) + ((x * mul + iii) * 4) + i];
								
							}
						}
					}
					vv /= mul;
        			vv /= mul;
        			vv /= 4;
        			v = v/2 + vv/2;
        		}
        		
        		
        		pixelsOut[pixelOffset+i] = Math.floor(v);
        	}
        	if (distance1[y * mul][x * mul] >= 0){
				pixelsOut[pixelOffset] = 200 - 10*distance1[y * mul][x * mul];
			}
			
        	
        }
      }
	  
      return pixelsOut;
    },

    helpers: {

      // http://stackoverflow.com/a/5624139
      hexToRGBa: function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16),
          255
        ] : null;
      }
    }

  };


// -- DepthMapper --

  var DepthMapper = function () {};

  DepthMapper.prototype.autoResize = true;

  DepthMapper.prototype.make = function (width, height) {
    // !!! Overwrite this method
    return [[0]];
  };

  DepthMapper.prototype.generate = function (width, height) {
    if (this.autoResize) return this.resize(this.make(width, height), width, height);
    else return this.make(width, height);
  };

  DepthMapper.prototype.resize = function (origDepthMap, width, height) {
    var origDepthMapY, x, y,
        resizedDepthMap = [],
        origDepthMapHeight = origDepthMap.length,
        origDepthMapWidth = origDepthMap[0].length;

    if (origDepthMapWidth === width && origDepthMapHeight === height) {
      return origDepthMap;
    }

    for (y = 0; y < height; y++) {
      resizedDepthMap[y] = new Float32Array(width);
      origDepthMapY = Math.floor(y * origDepthMapHeight / height);
      for (x = 0; x < width; x++) {
        resizedDepthMap[y][x] = origDepthMap[origDepthMapY][Math.floor(x * origDepthMapWidth / width)];
      }
    }

    return resizedDepthMap;
  };

  // Credit: backbone, underscore
  DepthMapper.extend = function (protoProps) {
    var parent = this;
    var child;

    var extend = function(obj) {
      if (!obj || (typeof obj != 'function' && typeof obj != 'object')) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  MagicEye.DepthMapper = DepthMapper;


  this.MagicEye = MagicEye;

}).call(this);
