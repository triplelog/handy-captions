/*! MagicEye.js (https://github.com/peeinears/MagicEye.js)
 *
 *  MIT License (http://www.opensource.org/licenses/mit-license.html)
 *  Copyright (c) 2014 Ian Pearce
 */

!(function(){
  'use strict';

  var MagicEye = {

    render: function (opts) {
      opts = opts || {};

      var defaultOptions = {
        width: null,
        height: null,
        depthMap: null,
        depthMapper: new MagicEye.DepthMapper(),
        imageType: 'png',
        rows: [0,-1],
        fullColors: [],
        seeded: [],
        colors: [
          [255, 255, 255, 255],
          [0, 0, 0, 255]
        ]
      };

      for (var property in defaultOptions) {
        if( ! opts.hasOwnProperty(property) ) opts[property] = defaultOptions[property];
      }

      var element, width, height, depthMap, pixelData, i;

      // find and set element
      if (opts.el) {
        element = (typeof opts.el === 'string' ? document.getElementById(opts.el) : opts.el);
        if (!element || !element.tagName) throw('MagicEye: Could not find element: ' + opts.el);
      }

      // use element's height and width unless height and width is provided
      width = opts.width || element.width;
      if (!width) throw('MagicEye: width not set and could not be inferred from element: ' + opts.el);
      height = opts.height || element.height;
      if (!height) throw('MagicEye: height not set and could not be inferred from element: ' + opts.el);

      // use depthMap if provided, otherwise use depthMap generated by given depthMapper
      if (opts.depthMap) {
        depthMap = opts.depthMap;
      } else if (opts.depthMapper) {
        depthMap = opts.depthMapper.generate(width, height);
      } else throw('MagicEye: no depthMap or depthMapper opts given');

      // convert hex colors to RGBa
      for (i = 0; i < opts.colors.length; i++) {
        if (typeof opts.colors[i] === 'string') {
          opts.colors[i] = this.helpers.hexToRGBa(opts.colors[i]);
        }
      }

      var retVal = this.generatePixelData({
        width: width,
        height: height,
        depthMap: depthMap,
        rows: opts.rows,
        fullColors: opts.fullColors,
        seeded: opts.seeded,
        colors: opts.colors
      });
      
      pixelData = retVal[0];
      var emojiLocations = retVal[1];

      switch (element.tagName) {
      case 'CANVAS':
        this.renderToCanvas(element, pixelData, width, height, opts.rows, emojiLocations);
        break;

      case 'IMG':
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        this.renderToCanvas(canvas, pixelData, width, height);
        element.src = canvas.toDataURL('image/' + (opts.imageType || 'png'));
        break;

      default:
        throw('MagicEye: el must be either a <canvas> or an <img>');
      }

      return this;
    },

    renderToCanvas: function (canvas, pixelData, width, height, rows, emojiLocations) {
      var context = canvas.getContext("2d");
      var yMin = 0;
	  var yMax = height;
	  //pixelData = new Uint8ClampedArray(width * height * 4);
	  if (rows[1] > -1){
	  	yMin = rows[0];
	  	yMax = rows[1];
	  	height = yMax - yMin;
	  	pixelData = pixelData.slice(yMin*width*4,yMax*width*4);
	  }
	  if (height == 0){return;}
      var imageData = context.createImageData(width, height);
      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, yMin);
      context.lineWidth = 1;
      context.strokeStyle = "black";
      var idxToEmoji = [];
      idxToEmoji.push('üòÇ');
      idxToEmoji.push('‚ù§Ô∏è');
      idxToEmoji.push('‚ú®');
      idxToEmoji.push('üî•');
      idxToEmoji.push('üíØ');
      idxToEmoji.push('üëÄ');
      idxToEmoji.push('üò°');
      idxToEmoji.push('üçÄ');
      idxToEmoji.push('üí©');
      idxToEmoji.push('üòç');
      idxToEmoji.push('üè¥‚Äç‚ò†Ô∏è');
      var emojiEl = document.querySelector('.emojiLayer');
      emojiEl.innerHTML = '';
      var divT = document.createElement('div');
      divT.classList.add('emojiDiv');
	  var iDiv = document.createElement('div');
	  divT.appendChild(iDiv);
      for (var y=yMin;y<yMax;y++){
      	var emojis = Object.keys(emojiLocations[y]);
      	for (var i in emojis){
      		break;
      		var e = parseInt(emojis[i]);
      		var sz = parseFloat(emojiLocations[y][e].sz);
      		var rc = parseInt(emojiLocations[y][e].color);
      		var op = parseFloat(emojiLocations[y][e].opacity);
      		var delay = parseFloat(emojiLocations[y][e].delay);
      		
      		var cx = e+sz/2;
      		var cy = y+sz/2;
      		var r = sz/2;
      		
      		if (y < 100){
      			//console.log(e,y,sz,cx,cy,r);
      		}
      		
			var idx = Math.floor(rc/37);
			
			
			/*context.font = parseInt(sz * 0.9) +'px serif';
			context.textAlign = "center"; 
			context.textBaseline = "middle"; 
			context.fillText(idxToEmoji[idx], cx, cy);
			*/
			
			var div = divT.cloneNode(true);
			div.style.left = e+"px";
			div.style.top = y+"px";
			div.style.height = sz+"px";
			div.style.width = sz+"px";
			div.style.fontSize = sz+"px";
			div.style.lineHeight = sz+"px";
			//div.style.animationDelay = (delay*5.0)+'s';
			//if (delay <0.01 || delay > 0.99){
			//	div.style.animationIterationCount = '1';
			//}
			if (rc == -720){
				var iDiv = div.querySelector('div');
				iDiv.innerHTML = idxToEmoji[7];
				
			}
			else {
				var iDiv = div.querySelector('div');
				iDiv.innerHTML = idxToEmoji[3];
				iDiv.style.transform = 'rotate('+rc+'deg)';
				iDiv.style.opacity = op;
			}
			
			emojiEl.appendChild(div);
      	}
      }
    },

    generatePixelData: function (opts) {

      /*
       * This algorithm was published in a paper authored by by Harold W.
       * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
       * translated from the C code that was featured in the article.
       * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
       */

      var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
          width = opts.width,
          height = opts.height,
          depthMap = opts.depthMap,
          rows = opts.rows,
          numColors = opts.colors.length,
          same, // points to a pixel to the right
          dpi = 36, // assuming output of 72 dots per inch
          eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
          mu = (1 / 3), // depth of field (fraction of viewing distance)
          pixels = new Uint8ClampedArray(width * height * 4);
	  
	  var yMin = 0;
	  var yMax = height;
	  if (rows[1] > -1){
	  	yMin = rows[0];
	  	yMax = rows[1];
	  }
	  var seeded = opts.seeded;
      // for each row
      var allChains = {};
      var emojiBlock = {};
      var emojiLocations = {};
      
      var sameColors = {};
      var allSame = {};
      var allAngles = {};
      var allDelays = {};
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	emojiLocations[y] = {};
      	sameColors[y]={};
      	allAngles[y]={};
      	allDelays[y]={};
      	for (x = 0; x < width; x++) {
          sameColors[y][x] = Math.random();
          allAngles[y][x] = -1;
          allDelays[y][x] = -1;
        }
        // max image width (for Uint16Array) is 65536
        same = new Uint16Array(width); // points to a pixel to the right

        for (x = 0; x < width; x++) {
          same[x] = x; // each pixel is initially linked with itself
        }
		
		var colorsFG = opts.fullColors[y];
		
		var chain = {};
        // for each column
        for (x = 0; x < width; x++) {

          z = depthMap[y][x][0];

          // stereo separation corresponding to z
          sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

          // x-values corresponding to left and right eyes
          left = Math.round(x - ((sep + (sep & y & 1)) / 2));
          right = left + sep;

          if (0 <= left && right < width) {

            // remove hidden surfaces
            t = 1;
            do {
              zt = z + (2 * (2 - (mu * z)) * t / (mu * eyeSep));
              visible = (depthMap[y][x-t][0] < zt) && (depthMap[y][x+t][0] < zt); // false if obscured
              t++;
            } while (visible && zt < 1);

            if (visible) {
              // record that left and right pixels are the same
              for (k = same[left]; k !== left && k !== right; k = same[left]) {
                if (k < right) {
                  left = k;
                } else {
                  left = right;
                  right = k;
                }
              }
              same[left] = right;
              if (z > 0.5){
              	if (y == 300 && x == 300){
					console.log(depthMap[y][x][1]);
				}
              	allAngles[y][left] = depthMap[y][x][1];
              	allAngles[y][right] = depthMap[y][x][1];
              	allDelays[y][left] = depthMap[y][x][2];
              	allDelays[y][right] = depthMap[y][x][2];
              }
              if (chain[right]){
              	if (chain[left]){
              		for (var i=0;i<chain[left].length;i++){
              			chain[right].push(chain[left][i]);
              		}
              		delete chain[left];
              	}
              	else {
              		chain[right].push(left);
              	}
              }
              else {
                chain[right]= [right];
              	if (chain[left]){
              		for (var i=0;i<chain[left].length;i++){
              			chain[right].push(chain[left][i]);
              		}
              		delete chain[left];
              	}
              	else {
              		chain[right].push(left);
              	}
              }
              
              
            }
            else {
            	if (z > 0.5){
            		
					allAngles[y][left] = depthMap[y][x][1];
					allAngles[y][right] = depthMap[y][x][1];
					allDelays[y][left] = depthMap[y][x][2];
              		allDelays[y][right] = depthMap[y][x][2];
                }
            }
          }
        }
		
		for (x = (width - 1); x >= 0; x--) {
			if (same[x] === x && !chain[x]){
				chain[x] = [x];
			}
		}
		
        for (x = (width - 1); x >= 0; x--) {
          pixelOffset = (y * width * 4) + (x * 4);
          if (same[x] === x) {
            // set random color
            rgba = colorsFG[x];
            //rgba[0] = 192 + Math.floor(Math.random()*64);
            //rgba[1] = 192 + Math.floor(Math.random()*64);
            //rgba[2] = 192 + Math.floor(Math.random()*64);
            rgba[0] = Math.floor(seeded[0][y][x]*256);
            rgba[1] = Math.floor(seeded[0][y][x]*256);
            rgba[2] = Math.floor(seeded[0][y][x]*256);
            /*for (var i=0;i<chain[x].length;i++){
				if (allAngles[y][chain[x][i]] > -1){
					rgba[0] = Math.floor(allAngles[y][chain[x][i]]/360*255);
					rgba[1] = Math.floor(allAngles[y][chain[x][i]]/360*255);
					rgba[2] = Math.floor(allAngles[y][chain[x][i]]/360*255);
				}
            }*/
            var block = true;
            
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = rgba[i];
            }
          } else {
            // constrained pixel, obey constraint
            pixelOffset = (y * width * 4) + (x * 4);
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = pixels[(y * width * 4) + (same[x] * 4) + i];
            }
          }
        }
        
		
		emojiBlock[y]={};
		
		this.helpers.setEmojis(0,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,0.99);
		
		if (y == 300){
			console.log(chain);
		}
		allSame[y]=same;
        allChains[y]=chain;
      }
      
      
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	sameColors[y]={};
      	same = allSame[y];
      	chain = allChains[y];
      	for (x = 0; x < width; x++) {
          sameColors[y][x] = Math.random();
        }
		this.helpers.setEmojis(1,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,0.99);
		
      }
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	sameColors[y]={};
      	same = allSame[y];
      	chain = allChains[y];
      	for (x = 0; x < width; x++) {
          sameColors[y][x] = Math.random();
        }
		this.helpers.setEmojis(2,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,0.98);
		
      }
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	sameColors[y]={};
      	same = allSame[y];
      	chain = allChains[y];
      	for (x = 0; x < width; x++) {
          sameColors[y][x] = Math.random();
        }
		this.helpers.setEmojis(3,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,0.97);
		
      }
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	sameColors[y]={};
      	same = allSame[y];
      	chain = allChains[y];
      	for (x = 0; x < width; x++) {
          sameColors[y][x] = Math.random();
        }
		this.helpers.setEmojis(4,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,0.96);
		
      }
      /*var chMax = 25;
      for (y = yMin+4; y < yMax-4; y++) {
			for (x = 0; x < width; x++) {
				for (var iii=0;iii<4;iii++){
					var zT = depthMap[y-iii][x];
					var zB = depthMap[y+iii][x];
					z = depthMap[y][x];
					if (z > zT){
						var ch = Math.round(Math.sqrt(z-zT)*chMax/(iii+4));
						// stereo separation corresponding to z
					  sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

					  // x-values corresponding to left and right eyes
					  left = Math.round(x - ((sep + (sep & y & 1)) / 2));
					  right = left + sep;

					  if (0 <= left && right < width) {

					
						  var pixelLeft = (y * width * 4) + (left * 4);
						  var pixelRight = (y * width * 4) + (right * 4);
						  pixels[pixelLeft + 0] = pixels[pixelLeft + 0] + ch;
						  pixels[pixelLeft + 1] = pixels[pixelLeft + 1] + ch;
						  pixels[pixelLeft + 2] = pixels[pixelLeft + 2] + ch;
						  pixels[pixelRight + 0] = pixels[pixelRight + 0] + ch;
						  pixels[pixelRight + 1] = pixels[pixelRight + 1] + ch;
						  pixels[pixelRight + 2] = pixels[pixelRight + 2] + ch;
						  if (pixels[pixelLeft + 0] > 255){pixels[pixelLeft + 0] = 255;}
						  if (pixels[pixelLeft + 1] > 255){pixels[pixelLeft + 1] = 255;}
						  if (pixels[pixelLeft + 2] > 255){pixels[pixelLeft + 2] = 255;}
						  if (pixels[pixelRight + 0] > 255){pixels[pixelRight + 0] = 255;}
						  if (pixels[pixelRight + 1] > 255){pixels[pixelRight + 1] = 255;}
						  if (pixels[pixelRight + 2] > 255){pixels[pixelRight + 2] = 255;}
					  
					  }
				    }
				    if (z > zB){
				    	var ch = Math.round(Math.sqrt(z-zB)*chMax/(iii+4));
						// stereo separation corresponding to z
					  sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

					  // x-values corresponding to left and right eyes
					  left = Math.round(x - ((sep + (sep & y & 1)) / 2));
					  right = left + sep;

					  if (0 <= left && right < width) {

					
						  var pixelLeft = (y * width * 4) + (left * 4);
						  var pixelRight = (y * width * 4) + (right * 4);
						  pixels[pixelLeft + 0] = pixels[pixelLeft + 0] - ch;
						  pixels[pixelLeft + 1] = pixels[pixelLeft + 1] - ch;
						  pixels[pixelLeft + 2] = pixels[pixelLeft + 2] - ch;
						  pixels[pixelRight + 0] = pixels[pixelRight + 0] - ch;
						  pixels[pixelRight + 1] = pixels[pixelRight + 1] - ch;
						  pixels[pixelRight + 2] = pixels[pixelRight + 2] - ch;
						  if (pixels[pixelLeft + 0] < 0){pixels[pixelLeft + 0] = 0;}
						  if (pixels[pixelLeft + 1] < 0){pixels[pixelLeft + 1] = 0;}
						  if (pixels[pixelLeft + 2] < 0){pixels[pixelLeft + 2] = 0;}
						  if (pixels[pixelRight + 0] < 0){pixels[pixelRight + 0] = 0;}
						  if (pixels[pixelRight + 1] < 0){pixels[pixelRight + 1] = 0;}
						  if (pixels[pixelRight + 2] < 0){pixels[pixelRight + 2] = 0;}
					  
					  }
				    }
					
					
				}
				
				
			}
	  }
	  */
	  
      return [pixels,emojiLocations];
    },

    helpers: {

      // http://stackoverflow.com/a/5624139
      hexToRGBa: function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16),
          255
        ] : null;
      },
      setEmojis: function(idx,seeded,width,yMin,y,same,chain,emojiBlock,emojiLocations,sameColors,allAngles,allDelays,skipP) {
      		var angleP = 1;
      		var rAngle = 120;
      		
      		for (x = (width - 1); x >= 0; x--) {
				  
				  if (same[x] === x) {
					// set random color
			
					var block = true;
					//if (colorsFG[x+1] && colorsFG[x+1][0] == colorsFG[x][0] && colorsFG[x+1][1] == colorsFG[x][1]){
					//	block = false;
					//}
					if (emojiBlock[y][x]){
						block = false;
					}
					var vbn = 60;
			
					var xi = x;
					//console.log(idx,y,x);
					//console.log(seeded[idx*3]);
					//console.log(seeded[idx*3][y]);
					var maxBlock = 16 + Math.floor(seeded[idx*3][y][x] * 14);
					var minBlock = 4 + Math.floor(seeded[idx*3+1][y][x] * 8);
					
					//var maxBlock = 16;
					//var minBlock = 4;
					
					if (seeded[idx*3+2][y][x] < skipP){
						block = false;
						continue;
					}
			
			
					
					for (var v=0;v<60;v++){
						if (v-maxBlock > vbn + 3){
							break;
						}
						if (!emojiLocations[y-v]){
							if (y-v >= 0 && v>0){vbn = 0;}
							continue;
						}
				
						//var emojis = Object.keys(emojiLocations[y-v]);
				
				
						if (chain[x]){
							for (var i in emojiLocations[y-v]){
								var lx = i;
								var ty = y-v;
								var e = emojiLocations[y-v][lx];
								var w = parseInt(e.sz);
								var maxHeight = v-w;
								if (maxHeight>= vbn){
									continue;
								}
								var maxWidth = -1;
								var maxSize = -1;
								for (var i=0;i<chain[x].length;i++){
									if (lx <= chain[x][i]){
										var mSz = Math.max(chain[x][i] - lx - w,0);
										if (mSz < maxWidth || maxWidth == -1){
											maxWidth = mSz;
										}
									}
								}
								if (maxWidth > -1){
									if (maxHeight < maxWidth){
										maxSize = maxWidth;
									}
									else {
										maxSize = maxHeight;
									}
								}
								else {
									maxSize = 60;
								}
								if (maxSize < vbn){
									vbn = maxSize;
								}
							}
						}
						else {
							vbn = 0;//Maybe need to do something better here with orphans
							break;
						}
				
					}
					
					vbn+=3;
			
			
					while (block){
						xi--;
						block = true;
						if (chain[x] && chain[xi] && chain[x].length == chain[xi].length){
							for (var i=0;i<chain[x].length;i++){
								if (chain[x][i] != chain[xi][i]+x-xi){
									block = false;
									break;
								}
							}
						}
						else {
							block = false;
						}
						
						if (block){
					
							//colorsFG[xi] = rgba;
					
						}
						else {
							if (xi < x - minBlock){
								if (vbn >= x - xi){
									var fullBlock = true;
									for (var v=1;v<x-xi;v++){
										for (var ii=0;ii<x-xi;ii++){
											for (var iii=0;iii<chain[x-ii].length;iii++) {
												var xx = chain[x-ii][iii];
												if (sameColors[y-v] && sameColors[y-v][xx] == sameColors[y-v][x]){
								
												}
												else {
													fullBlock = false;
												}
											}
										}
									}
									if (fullBlock){
										for (var v=1;v<x-xi;v++){
											for (var ii=0;ii<x-xi;ii++){
												for (var iii=0;iii<chain[x-ii].length;iii++) {
													var xx = chain[x-ii][iii];
													//pixels[(y-v)*width*4 + xx*4 + 0] = rgba[0];
													//pixels[(y-v)*width*4 + xx*4 + 1] = rgba[1];
													//pixels[(y-v)*width*4 + xx*4 + 2] = rgba[2];
													sameColors[y-v][xx]=sameColors[y][x];
													//emojiBlock[y-v][xx]=x-xi;
												}
											}
										}
									}
									var rc = Math.floor(seeded[idx][y][x]*360);
									//rc = allAngles[y][x];
									var rra ={};
									var maxDiff = 0;
									var delay = 0;
									if (Math.random() < angleP){
										for (var yy=y;yy>= y-(x-xi)+1 && yy >=yMin;yy--){
											
											var yangles = [];
											for (var iii=0;iii<chain[x-(x-xi)+1].length;iii++) {
												if (allAngles[yy][chain[x-(x-xi)+1][iii]] > -1){
													var rct = allAngles[yy][chain[x-(x-xi)+1][iii]];
													if (rra[rct]){
														rra[rct].push(chain[x-(x-xi)+1][iii]);
													}
													else {
														rra[rct]=[chain[x-(x-xi)+1][iii]];
													}
													yangles.push(parseInt(rct));
												}
											}
											for (var iii=0;iii<yangles.length;iii++){
												for (var iv=0;iv<yangles.length;iv++){
													var angleDiff = (yangles[iii] + 7200 - yangles[iv]) % 360;
													if (angleDiff > 180){
														angleDiff = 360 - angleDiff;
													}
													if (angleDiff > maxDiff && Math.abs(iii - iv) > 1){
														maxDiff = angleDiff;
													}
												}
											}
											
										}
									}
									var maxrc = 0;
									for (var k in rra){
										if (rra[k].length>maxrc){
											rc = parseInt(k);
											maxrc = rra[k].length;
										}
									}
									
									rc = rc + Math.floor(seeded[idx][y][x]*360/rAngle - 180/rAngle);
									
									for (var iii=0;iii<chain[x-(x-xi)+1].length;iii++) {
										if (y-(x-xi)+1>= yMin){
											var op = 1;
											if (iii == 0 && chain[x-(x-xi)+1][iii] < width - 85){
												op = 0.5;
											}
											else if (iii == chain[x-(x-xi)+1].length - 1 && chain[x-(x-xi)+1][iii] > 85){
												op = 0.5;
											}
											else if (iii == 1 && chain[x-(x-xi)+1][iii] < width - 170){
												op = 0.75;
											}
											else if (iii == chain[x-(x-xi)+1].length - 2 && chain[x-(x-xi)+1][iii] > 170){
												op = 0.75;
											}
											
											if (allDelays[y-(x-xi)+1] && allDelays[y-(x-xi)+1][chain[x-(x-xi)+1][iii]] > -1){
												delay = allDelays[y-(x-xi)+1][chain[x-(x-xi)+1][iii]];
											}
											else {
												delay = 0;
											}
											if (!delay){delay = 0;}
											if (delay < 0){delay = 0;}
											if (delay > 1){delay = 1;}
											
											if (maxDiff < 135){
												emojiLocations[y-(x-xi)+1][chain[x-(x-xi)+1][iii]]={'sz':(x-xi),'color':rc,'opacity':op,'delay':delay};
											}
											else {
												emojiLocations[y-(x-xi)+1][chain[x-(x-xi)+1][iii]]={'sz':(x-xi),'color':-720,'opacity':op,'delay':delay};
											}
										}
									}
								}
						
								for (var ii=0;ii<x-xi;ii++){
									
									for (var iii=0;iii<chain[x-ii].length;iii++) {
										var xx = chain[x-ii][iii];
										sameColors[y][xx]=sameColors[y][x];
										emojiBlock[y][xx]=1;
									}
								}
						
						
								break;
							}
						}
				
						if (xi < x - maxBlock){
							if (vbn >= maxBlock){
								var fullBlock = true;
								for (var v=1;v<maxBlock;v++){
									for (var ii=0;ii<maxBlock;ii++){
										for (var iii=0;iii<chain[x-ii].length;iii++) {
											var xx = chain[x-ii][iii];
											if (sameColors[y-v] && sameColors[y-v][xx] == sameColors[y-v][x]){
							
											}
											else {
												fullBlock = false;
											}
										}
									}
								}
						
								if (fullBlock){
									for (var v=1;v<maxBlock;v++){
										for (var ii=0;ii<maxBlock;ii++){
											for (var iii=0;iii<chain[x-ii].length;iii++) {
												var xx = chain[x-ii][iii];
												//pixels[(y-v)*width*4 + xx*4 + 0] = rgba[0];
												//pixels[(y-v)*width*4 + xx*4 + 1] = rgba[1];
												//pixels[(y-v)*width*4 + xx*4 + 2] = rgba[2];
												sameColors[y-v][xx]=sameColors[y][x];
												//emojiBlock[y-v][xx]=maxBlock;
											}
										}
									}
								}
								var rc = Math.floor(seeded[idx][y][x]*360);
								//rc = allAngles[y][x];
								var rra ={};
								var maxDiff = 0;
								var delay = 0;
								if (Math.random() < angleP){
									for (var yy=y;yy>= y-(maxBlock)+1 && yy >=yMin;yy--){
										var yangles = [];
										for (var iii=0;iii<chain[x-maxBlock+1].length;iii++) {
											if (allAngles[yy][chain[x-maxBlock+1][iii]] > -1){
												var rct = allAngles[yy][chain[x-maxBlock+1][iii]];
												if (rra[rct]){
													rra[rct].push(chain[x-maxBlock+1][iii]);
												}
												else {
													rra[rct]=[chain[x-maxBlock+1][iii]];
												}
												yangles.push(parseInt(rct));
											}
											
										}
										for (var iii=0;iii<yangles.length;iii++){
											for (var iv=0;iv<yangles.length;iv++){
												var angleDiff = (yangles[iii] + 7200 - yangles[iv]) % 360;
												if (angleDiff > 180){
													angleDiff = 360 - angleDiff;
												}
												if (angleDiff > maxDiff && Math.abs(iii - iv) > 1){
													maxDiff = angleDiff;
												}
											}
										}
									}
								}
								
								var maxrc = 0;
								
								for (var k in rra){
									if (rra[k].length>maxrc){
										rc = parseInt(k);
										maxrc = rra[k].length;
									}
								}
								
								rc = rc + Math.floor(seeded[idx][y][x]*360/rAngle - 180/rAngle);
									
								for (var iii=0;iii<chain[x-maxBlock+1].length;iii++) {
									if (y-maxBlock+1>= yMin){
										var op = 1;
										if (iii == 0 && chain[x-maxBlock+1][iii] < width - 85){
											op = 0.5;
										}
										if (iii == chain[x-maxBlock+1].length - 1 && chain[x-maxBlock+1][iii] > 85){
											op = 0.5;
										}
										
										if (allDelays[y-maxBlock+1] && allDelays[y-maxBlock+1][chain[x-maxBlock+1][iii]] > -1){
											delay = allDelays[y-maxBlock+1][chain[x-maxBlock+1][iii]];
										}
										else {
											delay = 0;
										}
										if (!delay){delay = 0;}
										if (delay < 0){delay = 0;}
										if (delay > 1){delay = 1;}
										if (maxDiff < 135){
											emojiLocations[y-maxBlock+1][chain[x-maxBlock+1][iii]]={'sz':maxBlock,'color':rc,'opacity':op,'delay':delay};
										}
										else {
											emojiLocations[y-maxBlock+1][chain[x-maxBlock+1][iii]]={'sz':maxBlock,'color':-720,'opacity':op,'delay':delay};
										}
									}
							
								}
							}
					
							for (var ii=0;ii<maxBlock;ii++){
								
								for (var iii=0;iii<chain[x-ii].length;iii++) {
									var xx = chain[x-ii][iii];
									sameColors[y][xx]=sameColors[y][x];
									emojiBlock[y][xx]=1;
								}
							}
					
							break;
						}
					}
					
			
				  }
				}
      }
    }

  };


// -- DepthMapper --

  var DepthMapper = function () {};

  DepthMapper.prototype.autoResize = true;

  DepthMapper.prototype.make = function (width, height) {
    // !!! Overwrite this method
    return [[0]];
  };

  DepthMapper.prototype.generate = function (width, height) {
    if (this.autoResize) return this.resize(this.make(width, height), width, height);
    else return this.make(width, height);
  };

  DepthMapper.prototype.resize = function (origDepthMap, width, height) {
    var origDepthMapY, x, y,
        resizedDepthMap = [],
        origDepthMapHeight = origDepthMap.length,
        origDepthMapWidth = origDepthMap[0].length;

    if (origDepthMapWidth === width && origDepthMapHeight === height) {
      return origDepthMap;
    }

    for (y = 0; y < height; y++) {
      resizedDepthMap[y] = new Float32Array(width);
      origDepthMapY = Math.floor(y * origDepthMapHeight / height);
      for (x = 0; x < width; x++) {
        resizedDepthMap[y][x] = origDepthMap[origDepthMapY][Math.floor(x * origDepthMapWidth / width)];
      }
    }

    return resizedDepthMap;
  };

  // Credit: backbone, underscore
  DepthMapper.extend = function (protoProps) {
    var parent = this;
    var child;

    var extend = function(obj) {
      if (!obj || (typeof obj != 'function' && typeof obj != 'object')) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  MagicEye.DepthMapper = DepthMapper;


  this.MagicEye = MagicEye;

}).call(this);
