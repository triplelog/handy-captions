/*! MagicEye.js (https://github.com/peeinears/MagicEye.js)
 *
 *  MIT License (http://www.opensource.org/licenses/mit-license.html)
 *  Copyright (c) 2014 Ian Pearce
 */

!(function(){
  'use strict';

  var MagicEye = {

    render: function (opts) {
      opts = opts || {};

      var defaultOptions = {
        width: null,
        height: null,
        depthMap: null,
        depthMapper: new MagicEye.DepthMapper(),
        imageType: 'png',
        rows: [0,-1],
        fullColors: [],
        colors: [
          [255, 255, 255, 255],
          [0, 0, 0, 255]
        ]
      };

      for (var property in defaultOptions) {
        if( ! opts.hasOwnProperty(property) ) opts[property] = defaultOptions[property];
      }

      var element, width, height, depthMap, pixelData, i;

      // find and set element
      if (opts.el) {
        element = (typeof opts.el === 'string' ? document.getElementById(opts.el) : opts.el);
        if (!element || !element.tagName) throw('MagicEye: Could not find element: ' + opts.el);
      }

      // use element's height and width unless height and width is provided
      width = opts.width || element.width;
      if (!width) throw('MagicEye: width not set and could not be inferred from element: ' + opts.el);
      height = opts.height || element.height;
      if (!height) throw('MagicEye: height not set and could not be inferred from element: ' + opts.el);

      // use depthMap if provided, otherwise use depthMap generated by given depthMapper
      if (opts.depthMap) {
        depthMap = opts.depthMap;
      } else if (opts.depthMapper) {
        depthMap = opts.depthMapper.generate(width, height);
      } else throw('MagicEye: no depthMap or depthMapper opts given');

      // convert hex colors to RGBa
      for (i = 0; i < opts.colors.length; i++) {
        if (typeof opts.colors[i] === 'string') {
          opts.colors[i] = this.helpers.hexToRGBa(opts.colors[i]);
        }
      }

      var retVal = this.generatePixelData({
        width: width,
        height: height,
        depthMap: depthMap,
        rows: opts.rows,
        fullColors: opts.fullColors,
        colors: opts.colors
      });
      
      pixelData = retVal[0];
      var emojiLocations = retVal[1];

      switch (element.tagName) {
      case 'CANVAS':
        this.renderToCanvas(element, pixelData, width, height, opts.rows, emojiLocations);
        break;

      case 'IMG':
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        this.renderToCanvas(canvas, pixelData, width, height);
        element.src = canvas.toDataURL('image/' + (opts.imageType || 'png'));
        break;

      default:
        throw('MagicEye: el must be either a <canvas> or an <img>');
      }

      return this;
    },

    renderToCanvas: function (canvas, pixelData, width, height, rows, emojiLocations) {
      var context = canvas.getContext("2d");
      var yMin = 0;
	  var yMax = height;
	  pixelData = new Uint8ClampedArray(width * height * 4);
	  if (rows[1] > -1){
	  	yMin = rows[0];
	  	yMax = rows[1];
	  	height = yMax - yMin;
	  	pixelData = pixelData.slice(yMin*width*4,yMax*width*4);
	  }
	  if (height == 0){return;}
      var imageData = context.createImageData(width, height);
      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, yMin);
      context.lineWidth = 1;
      context.strokeStyle = "black";
      var idxToEmoji = [];
      idxToEmoji.push('üòÇ');
      idxToEmoji.push('‚ù§Ô∏è');
      idxToEmoji.push('‚ú®');
      idxToEmoji.push('üî•');
      idxToEmoji.push('üíØ');
      idxToEmoji.push('üëÄ');
      idxToEmoji.push('üò°');
      idxToEmoji.push('üçÄ');
      idxToEmoji.push('üí©');
      idxToEmoji.push('üòç');
      for (var y=yMin;y<yMax;y++){
      	var emojis = Object.keys(emojiLocations[y]);
      	for (var i in emojis){
      		var e = parseInt(emojis[i]);
      		var sz = parseFloat(emojiLocations[y][e].sz);
      		var rc = parseInt(emojiLocations[y][e].color);
      		
      		
      		var cx = e+sz/2;
      		var cy = y+sz/2;
      		var r = sz/2;
      		context.strokeStyle = "rgb("+rc+",0,0)";
      		if (y < 100){
      			//console.log(e,y,sz,cx,cy,r);
      		}
      		if (rc < 0){
				context.beginPath();
				context.arc(cx,cy, r, 0, Math.PI * 2, true);
				context.stroke();
				context.closePath();
      		}
      		else {
      			var idx = Math.floor(rc/26);
				context.font = parseInt(sz * 0.9) +'px serif';
				// use these alignment properties for "better" positioning
				context.textAlign = "center"; 
				context.textBaseline = "middle"; 
				// draw the emoji
				context.fillText(idxToEmoji[idx], cx, cy);
			}
      	}
      }
    },

    generatePixelData: function (opts) {

      /*
       * This algorithm was published in a paper authored by by Harold W.
       * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
       * translated from the C code that was featured in the article.
       * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
       */

      var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
          width = opts.width,
          height = opts.height,
          depthMap = opts.depthMap,
          rows = opts.rows,
          numColors = opts.colors.length,
          same, // points to a pixel to the right
          dpi = 72, // assuming output of 72 dots per inch
          eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
          mu = (1 / 3), // depth of field (fraction of viewing distance)
          pixels = new Uint8ClampedArray(width * height * 4);
	  
	  var yMin = 0;
	  var yMax = height;
	  if (rows[1] > -1){
	  	yMin = rows[0];
	  	yMax = rows[1];
	  }
      // for each row
      var allChains = {};
      var emojiBlock = {};
      var emojiLocations = {};
      for (y = yMin; y < yMax; y++) {
      	emojiBlock[y]={};
      	emojiLocations[y] = {};
        // max image width (for Uint16Array) is 65536
        same = new Uint16Array(width); // points to a pixel to the right

        for (x = 0; x < width; x++) {
          same[x] = x; // each pixel is initially linked with itself
        }
		
		var colorsFG = opts.fullColors[y];
		
		var chain = {};
        // for each column
        for (x = 0; x < width; x++) {

          z = depthMap[y][x];

          // stereo separation corresponding to z
          sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

          // x-values corresponding to left and right eyes
          left = Math.round(x - ((sep + (sep & y & 1)) / 2));
          right = left + sep;

          if (0 <= left && right < width) {

            // remove hidden surfaces
            t = 1;
            do {
              zt = z + (2 * (2 - (mu * z)) * t / (mu * eyeSep));
              visible = (depthMap[y][x-t] < zt) && (depthMap[y][x+t] < zt); // false if obscured
              t++;
            } while (visible && zt < 1);

            if (visible) {
              // record that left and right pixels are the same
              for (k = same[left]; k !== left && k !== right; k = same[left]) {
                if (k < right) {
                  left = k;
                } else {
                  left = right;
                  right = k;
                }
              }
              same[left] = right;
              if (chain[right]){
              	if (chain[left]){
              		for (var i=0;i<chain[left].length;i++){
              			chain[right].push(chain[left][i]);
              		}
              		delete chain[left];
              	}
              	else {
              		chain[right].push(left);
              	}
              }
              else {
                chain[right]= [right];
              	if (chain[left]){
              		for (var i=0;i<chain[left].length;i++){
              			chain[right].push(chain[left][i]);
              		}
              		delete chain[left];
              	}
              	else {
              		chain[right].push(left);
              	}
              }
              
            }
          }
        }

        for (x = (width - 1); x >= 0; x--) {
          pixelOffset = (y * width * 4) + (x * 4);
          if (same[x] === x) {
            // set random color
            rgba = colorsFG[x];
            rgba[0] = Math.floor(Math.random()*255);
            rgba[1] = Math.floor(Math.random()*255);
            rgba[2] = Math.floor(Math.random()*255);
            var block = true;
            //if (colorsFG[x+1] && colorsFG[x+1][0] == colorsFG[x][0] && colorsFG[x+1][1] == colorsFG[x][1]){
            //	block = false;
            //}
            if (emojiBlock[y][x]){
            	block = false;
            }
            var vbn = 1;
            for (var v=1;v<25;v++){
				//if (opts.fullColors[y-v] && (opts.fullColors[y-v][x][0] != opts.fullColors[y-v+1][x][0] || opts.fullColors[y-v][x][1] != opts.fullColors[y-v+1][x][1])){
				//	vbn++;
				//}
				var open = true;
				var emojis = Object.keys(emojiLocations[y-v]);
				var lx = 
				
				if (chain[x]){
					for (var i in emojis){
						var lx = emojis[i];
						var ty = y-v;
						var e = emojiLocations[y-v][lx];
						var w = parseInt(e.sz);
						if (w < v){
							continue;
						}
						
					
						for (var i=0;i<chain[x].length;i++){
							if (lx <= chain[x][i] - v && chain[x][i] <= lx + w){
								open = false;
							}
						}
					}
				}
				else {
					vbn = 0;//Maybe need to do something better here with orphans
					break;
				}
				if (open){
					vbn++;
				}
				else {
					break;
				}
			}
			
            var xi = x;
            var maxBlock = 10;// + Math.floor(Math.random() * 13);
            var minBlock = 4;
            while (block){
            	xi--;
            	block = true;
				if (chain[x] && chain[xi] && chain[x].length == chain[xi].length){
					for (var i=0;i<chain[x].length;i++){
						if (chain[x][i] != chain[xi][i]+x-xi){
							block = false;
							break;
						}
					}
				}
				else {
					block = false;
				}
				
				if (block){
					
					//colorsFG[xi] = rgba;
					
				}
				else {
					if (xi < x - minBlock){
						if (vbn >= x - xi){
							var fullBlock = true;
							for (var v=1;v<x-xi;v++){
								for (var ii=0;ii<x-xi;ii++){
									for (var iii=0;iii<chain[x-ii].length;iii++) {
										var xx = chain[x-ii][iii];
										if (opts.fullColors[y-v] && opts.fullColors[y-v][xx][0] == opts.fullColors[y-v][x][0] && opts.fullColors[y-v][xx][1] == opts.fullColors[y-v][x][1]){
								
										}
										else {
											fullBlock = false;
										}
									}
								}
							}
							if (fullBlock){
								for (var v=1;v<x-xi;v++){
									for (var ii=0;ii<x-xi;ii++){
										for (var iii=0;iii<chain[x-ii].length;iii++) {
											var xx = chain[x-ii][iii];
											//pixels[(y-v)*width*4 + xx*4 + 0] = rgba[0];
											//pixels[(y-v)*width*4 + xx*4 + 1] = rgba[1];
											//pixels[(y-v)*width*4 + xx*4 + 2] = rgba[2];
											opts.fullColors[y-v][xx]=opts.fullColors[y][x];
											//emojiBlock[y-v][xx]=x-xi;
										}
									}
								}
							}
							var rc = Math.floor(Math.random()*255);
							for (var iii=0;iii<chain[x-(x-xi)+1].length;iii++) {
								if (y-(x-xi)+1>= 0){
									emojiLocations[y-(x-xi)+1][chain[x-(x-xi)+1][iii]]={'sz':(x-xi),'color':rc};
								}
							}
						}
						
						for (var ii=0;ii<x-xi;ii++){
							colorsFG[x-ii] = rgba;
							for (var iii=0;iii<chain[x-ii].length;iii++) {
								var xx = chain[x-ii][iii];
								opts.fullColors[y][xx]=opts.fullColors[y][x];
								emojiBlock[y][xx]=1;
							}
						}
						
						
						break;
					}
				}
				
				if (xi < x - maxBlock){
					if (vbn >= maxBlock){
						var fullBlock = true;
						for (var v=1;v<maxBlock;v++){
							for (var ii=0;ii<maxBlock;ii++){
								for (var iii=0;iii<chain[x-ii].length;iii++) {
									var xx = chain[x-ii][iii];
									if (opts.fullColors[y-v] && opts.fullColors[y-v][xx][0] == opts.fullColors[y-v][x][0] && opts.fullColors[y-v][xx][1] == opts.fullColors[y-v][x][1]){
							
									}
									else {
										fullBlock = false;
									}
								}
							}
						}
						
						if (fullBlock){
							for (var v=1;v<maxBlock;v++){
								for (var ii=0;ii<maxBlock;ii++){
									for (var iii=0;iii<chain[x-ii].length;iii++) {
										var xx = chain[x-ii][iii];
										//pixels[(y-v)*width*4 + xx*4 + 0] = rgba[0];
										//pixels[(y-v)*width*4 + xx*4 + 1] = rgba[1];
										//pixels[(y-v)*width*4 + xx*4 + 2] = rgba[2];
										opts.fullColors[y-v][xx]=opts.fullColors[y][x];
										//emojiBlock[y-v][xx]=maxBlock;
									}
								}
							}
						}
						var rc = Math.floor(Math.random()*255);
						for (var iii=0;iii<chain[x-maxBlock+1].length;iii++) {
							if (y-maxBlock+1>= 0){
								emojiLocations[y-maxBlock+1][chain[x-maxBlock+1][iii]]={'sz':maxBlock,'color':rc};
							}
							
						}
					}
					
					for (var ii=0;ii<maxBlock;ii++){
						colorsFG[x-ii] = rgba;
						for (var iii=0;iii<chain[x-ii].length;iii++) {
							var xx = chain[x-ii][iii];
							opts.fullColors[y][xx]=opts.fullColors[y][x];
							emojiBlock[y][xx]=1;
						}
					}
					
					break;
				}
            }
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = rgba[i];
            }
          } else {
            // constrained pixel, obey constraint
            pixelOffset = (y * width * 4) + (x * 4);
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = pixels[(y * width * 4) + (same[x] * 4) + i];
            }
          }
        }
        allChains[y]=chain;
      }
      /*var chMax = 25;
      for (y = yMin+4; y < yMax-4; y++) {
			for (x = 0; x < width; x++) {
				for (var iii=0;iii<4;iii++){
					var zT = depthMap[y-iii][x];
					var zB = depthMap[y+iii][x];
					z = depthMap[y][x];
					if (z > zT){
						var ch = Math.round(Math.sqrt(z-zT)*chMax/(iii+4));
						// stereo separation corresponding to z
					  sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

					  // x-values corresponding to left and right eyes
					  left = Math.round(x - ((sep + (sep & y & 1)) / 2));
					  right = left + sep;

					  if (0 <= left && right < width) {

					
						  var pixelLeft = (y * width * 4) + (left * 4);
						  var pixelRight = (y * width * 4) + (right * 4);
						  pixels[pixelLeft + 0] = pixels[pixelLeft + 0] + ch;
						  pixels[pixelLeft + 1] = pixels[pixelLeft + 1] + ch;
						  pixels[pixelLeft + 2] = pixels[pixelLeft + 2] + ch;
						  pixels[pixelRight + 0] = pixels[pixelRight + 0] + ch;
						  pixels[pixelRight + 1] = pixels[pixelRight + 1] + ch;
						  pixels[pixelRight + 2] = pixels[pixelRight + 2] + ch;
						  if (pixels[pixelLeft + 0] > 255){pixels[pixelLeft + 0] = 255;}
						  if (pixels[pixelLeft + 1] > 255){pixels[pixelLeft + 1] = 255;}
						  if (pixels[pixelLeft + 2] > 255){pixels[pixelLeft + 2] = 255;}
						  if (pixels[pixelRight + 0] > 255){pixels[pixelRight + 0] = 255;}
						  if (pixels[pixelRight + 1] > 255){pixels[pixelRight + 1] = 255;}
						  if (pixels[pixelRight + 2] > 255){pixels[pixelRight + 2] = 255;}
					  
					  }
				    }
				    if (z > zB){
				    	var ch = Math.round(Math.sqrt(z-zB)*chMax/(iii+4));
						// stereo separation corresponding to z
					  sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

					  // x-values corresponding to left and right eyes
					  left = Math.round(x - ((sep + (sep & y & 1)) / 2));
					  right = left + sep;

					  if (0 <= left && right < width) {

					
						  var pixelLeft = (y * width * 4) + (left * 4);
						  var pixelRight = (y * width * 4) + (right * 4);
						  pixels[pixelLeft + 0] = pixels[pixelLeft + 0] - ch;
						  pixels[pixelLeft + 1] = pixels[pixelLeft + 1] - ch;
						  pixels[pixelLeft + 2] = pixels[pixelLeft + 2] - ch;
						  pixels[pixelRight + 0] = pixels[pixelRight + 0] - ch;
						  pixels[pixelRight + 1] = pixels[pixelRight + 1] - ch;
						  pixels[pixelRight + 2] = pixels[pixelRight + 2] - ch;
						  if (pixels[pixelLeft + 0] < 0){pixels[pixelLeft + 0] = 0;}
						  if (pixels[pixelLeft + 1] < 0){pixels[pixelLeft + 1] = 0;}
						  if (pixels[pixelLeft + 2] < 0){pixels[pixelLeft + 2] = 0;}
						  if (pixels[pixelRight + 0] < 0){pixels[pixelRight + 0] = 0;}
						  if (pixels[pixelRight + 1] < 0){pixels[pixelRight + 1] = 0;}
						  if (pixels[pixelRight + 2] < 0){pixels[pixelRight + 2] = 0;}
					  
					  }
				    }
					
					
				}
				
				
			}
	  }
	  */
	  
      return [pixels,emojiLocations];
    },

    helpers: {

      // http://stackoverflow.com/a/5624139
      hexToRGBa: function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16),
          255
        ] : null;
      }
    }

  };


// -- DepthMapper --

  var DepthMapper = function () {};

  DepthMapper.prototype.autoResize = true;

  DepthMapper.prototype.make = function (width, height) {
    // !!! Overwrite this method
    return [[0]];
  };

  DepthMapper.prototype.generate = function (width, height) {
    if (this.autoResize) return this.resize(this.make(width, height), width, height);
    else return this.make(width, height);
  };

  DepthMapper.prototype.resize = function (origDepthMap, width, height) {
    var origDepthMapY, x, y,
        resizedDepthMap = [],
        origDepthMapHeight = origDepthMap.length,
        origDepthMapWidth = origDepthMap[0].length;

    if (origDepthMapWidth === width && origDepthMapHeight === height) {
      return origDepthMap;
    }

    for (y = 0; y < height; y++) {
      resizedDepthMap[y] = new Float32Array(width);
      origDepthMapY = Math.floor(y * origDepthMapHeight / height);
      for (x = 0; x < width; x++) {
        resizedDepthMap[y][x] = origDepthMap[origDepthMapY][Math.floor(x * origDepthMapWidth / width)];
      }
    }

    return resizedDepthMap;
  };

  // Credit: backbone, underscore
  DepthMapper.extend = function (protoProps) {
    var parent = this;
    var child;

    var extend = function(obj) {
      if (!obj || (typeof obj != 'function' && typeof obj != 'object')) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  MagicEye.DepthMapper = DepthMapper;


  this.MagicEye = MagicEye;

}).call(this);
