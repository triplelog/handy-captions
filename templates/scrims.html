<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
    {% block meta %}
    <meta name="description" content=".">    <title>CSS City</title>  
    <link rel="icon" type="image/png" href="../chfaviconcrop.png">
    {% endblock %}
    


{% block stylesheets %}
{% endblock %}


<style>

.input {
	position: absolute;
	left: 0px;
	top:0px;
	width: 100%;
	height: 50%;
	display: inline-block;
	border: 1px solid black;
	touch-action: none;
	
}
.output {
	position: absolute;
	left: 0px;
	top:50%;
	width: 300px;
	height: 300px;
	display: inline-block;
	border: 1px solid red;
	
	/*background-image: url("img/pexels-photo-963278.jpeg");
	background-color: black;
	background-size: 300px 300px;*/
	
}
.o2 {
	position: absolute;
	left: 350px;
	top:0%;
	width: 300px;
	height: 300px;
	display: inline-block;
	border: 1px solid red;
	display: inline-block;
	/*background-blend-mode: hue;*/
	/*background-image: url("img/pexels-photo-963278.jpeg");
	background-color: black;
	background-size: 300px 300px;*/
	
}
.o2 svg {
	/*background-blend-mode: hue;*/
}
.tools {
	position: absolute;
	left: 300px;
	top:50%;
	display: inline-block;
	
}
.pt {
	position: absolute;
	display: inline-block;
	background: black;
	width: 1px;
	height: 1px;
}

#textSVG {
	display: none;
}
#heart, #heartBig, #heartFill {
	position: absolute;
}

</style>
</head>
<body>


<img id="imgBG" src="img/pexels-photo-963278.jpeg" style="display: none;"/>
<div class="input">

</div>

	<canvas class="output" width="300px" height="300px">
		
	</canvas>
<div class="o2" >
	<svg id="textSVG" viewBox="0 0 300 300" width="300" height="300" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<defs>
			<linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
			  <stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" />
			  <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
			</linearGradient>
			<radialGradient id="grad2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%" gradientUnits="userSpaceOnUse">
			  <stop offset="0%" style="stop-color:rgb(0,0,0);stop-opacity:1" />
			  <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
			</radialGradient>
			<pattern id="img1" patternUnits="userSpaceOnUse" width="100%" height="100%">
				<image href="img/pnggrad16rgb.png" x="0" y="0" width="100%" height="100%" />
			</pattern>
		</defs>
		<g class="hullSVG">
			{% for idx in range(0,1) %}<path class="convexHull-{{ idx }}" fill="rgba(255,0,0,{{ 0.25 }})" {% if idx == 0 %}stroke="none"{% else %}stroke="none"{% endif %} stroke-width="2" d="M5 5 150 5 295 25 295 275 150 295 5 295Z" />
			{% endfor %}
			{% for idx in range(1,10) %}<path class="convexHull-{{ idx }}" fill="rgba(255,0,0,{{ 0.05 - idx*1.0/400.0 }})" {% if idx == 0 %}stroke="none"{% else %}stroke="none"{% endif %} stroke-width="2" d="M5 5 150 5 295 25 295 275 150 295 5 295Z" />
			{% endfor %}
		</g>
		<g class="bgSVG">

		</g>
		<g class="fgSVG">
			
		</g>
	</svg>
	<svg id="heartBig" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="-100 -100 845 785" version="1.0" width="100%" height="100%">

		<path d="M 297.29747,550.86823 C 283.52243,535.43191 249.1268,505.33855 220.86277,483.99412 C 137.11867,420.75228 125.72108,411.5999 91.719238,380.29088 C 29.03471,322.57071 2.413622,264.58086 2.5048478,185.95124 C 2.5493594,147.56739 5.1656152,132.77929 15.914734,110.15398 C 34.151433,71.768267 61.014996,43.244667 95.360052,25.799457 C 119.68545,13.443675 131.6827,7.9542046 172.30448,7.7296236 C 214.79777,7.4947896 223.74311,12.449347 248.73919,26.181459 C 279.1637,42.895777 310.47909,78.617167 316.95242,103.99205 L 320.95052,119.66445 L 330.81015,98.079942 C 386.52632,-23.892986 564.40851,-22.06811 626.31244,101.11153 C 645.95011,140.18758 648.10608,223.6247 630.69256,270.6244 C 607.97729,331.93377 565.31255,378.67493 466.68622,450.30098 C 402.0054,497.27462 328.80148,568.34684 323.70555,578.32901 C 317.79007,589.91654 323.42339,580.14491 297.29747,550.86823 z" style="fill:rgba(255,0,0,.5)"/>

	</svg>
	<svg id="heart" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="-100 -100 845 785" version="1.0" width="100%" height="100%">

		<path d="M 297.29747,550.86823 C 283.52243,535.43191 249.1268,505.33855 220.86277,483.99412 C 137.11867,420.75228 125.72108,411.5999 91.719238,380.29088 C 29.03471,322.57071 2.413622,264.58086 2.5048478,185.95124 C 2.5493594,147.56739 5.1656152,132.77929 15.914734,110.15398 C 34.151433,71.768267 61.014996,43.244667 95.360052,25.799457 C 119.68545,13.443675 131.6827,7.9542046 172.30448,7.7296236 C 214.79777,7.4947896 223.74311,12.449347 248.73919,26.181459 C 279.1637,42.895777 310.47909,78.617167 316.95242,103.99205 L 320.95052,119.66445 L 330.81015,98.079942 C 386.52632,-23.892986 564.40851,-22.06811 626.31244,101.11153 C 645.95011,140.18758 648.10608,223.6247 630.69256,270.6244 C 607.97729,331.93377 565.31255,378.67493 466.68622,450.30098 C 402.0054,497.27462 328.80148,568.34684 323.70555,578.32901 C 317.79007,589.91654 323.42339,580.14491 297.29747,550.86823 z" style="fill:rgba(255,0,0,.5)"/>

	</svg>
	<svg id="heartFill" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="-100 -100 845 785" version="1.0" width="100%" height="100%">

		
	</svg>
</div>
<div class="tools">
	<select>
		<option value="heart">Heart</option>
		<option value="cloud">Cloud</option>
		<option value="cloud">Animal</option>
		<option value="cloud">Star</option>
	</select>
	<input type="radio" >Monochrome</input>
	<input type="radio" >Opacity</input>
	<button onclick="heart();">Heart</button>
	<button onclick="selectGroup();">Group</button>
	<button onclick="downloadImage();">Download</button>
	<a id="downloadLink" download="a.png" href="">Download</a>
</div>
<script>
var canvas = document.querySelector('canvas');
var ctx = canvas.getContext("2d");
var img = document.getElementById("imgBG");
img.onload = function(){ctx.drawImage(img, 0, 0, 300, 300);}

var curveWorker = new Worker('js/curveWorker.js');
var inputEl = document.querySelector('.input');
var outputEl = document.querySelector('.output');
inputEl.addEventListener('pointerdown',inputDown);
inputEl.addEventListener('pointermove',inputMove);
inputEl.addEventListener('pointerup',inputUp);

var currentCurve = [];
var allCurves = {};
var isDown = false;
var isGroup = false;

curveWorker.onmessage = function(evt){
	if (evt.data.type == 'inputCurve'){
		for (var i=0;i<evt.data.points.length;i++){
			drawCurveIn(evt.data.points[i]);
		}
	}
	else if (evt.data.type == 'outputCurve'){
		drawCurveOut(evt.data.id,evt.data.pd,evt.data.startPoint,evt.data.endPoint);
	}
	else if (evt.data.type == 'convexHull'){
		drawConvexHull(evt.data.pdArray);
	}
}

function inputDown(evt) {
	curveWorker.postMessage({'type':'down','x':evt.clientX,'y':evt.clientY});
	isDown = true;
}
function inputMove(evt) {
	if (isDown){
		curveWorker.postMessage({'type':'move','x':evt.clientX,'y':evt.clientY});
	}
}
function inputUp(evt) {
	if (isDown){
		console.log(evt);
		isDown = false;
		
		curveWorker.postMessage({'type':'up','x':evt.clientX,'y':evt.clientY});
	}
}

function drawCurveIn(pt){
	
	var el = document.createElement('div');
	el.classList.add("pt");
	el.style.left = pt[0]+"px";
	el.style.top = pt[1]+"px";
	inputEl.appendChild(el);
}
function drawCurveOut(id,pd,startPoint,endPoint){
	var svg = document.querySelector('.o2 .bgSVG');
	var path0 = document.createElementNS("http://www.w3.org/2000/svg", 'path');
	
	path0.setAttribute('d',pd);
	path0.setAttribute('stroke','rgba(255,255,255,.5)');
	path0.setAttribute('stroke-width','11');
	path0.setAttribute('fill','none');
	path0.id = "bbg-"+id;
	svg.appendChild(path0);
	

	var path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
	
	path.setAttribute('d',pd);
	path.setAttribute('stroke','rgb(255,255,255)');
	path.setAttribute('stroke-width','7');
	path.setAttribute('fill','none');
	path.id = "bg-"+id;
	svg.appendChild(path);
	
	var svg2 = document.querySelector('.o2  .fgSVG');
	var path2 = document.createElementNS("http://www.w3.org/2000/svg", 'path');
	path2.setAttribute('d',pd);
	path2.setAttribute('stroke','rgb(0,0,255)');
	path2.setAttribute('stroke-width','5');
	path2.setAttribute('fill','none');
	path2.id = "fg-"+id;
	svg2.appendChild(path2);
	
	allCurves[id]= currentCurve;
	console.log(allCurves);
}

function drawConvexHull(pdArray) {
	for (var i=0;i<10;i++){
		var el = document.querySelector('.convexHull-'+i);
		el.setAttribute('d',pdArray[i]);
	}
	
	let clonedSvgElement = document.getElementById("textSVG").cloneNode(true);
	var img2 = new Image();
	
	img2.onload = function() {
		ctx.drawImage(img, 0, 0, 300, 300);
		ctx.drawImage(img2, 0, 0,300,300);
		
	}
	img2.src = "data:image/svg+xml;base64," + window.btoa(clonedSvgElement.outerHTML);
	
	

	

}
function heart() {
	var el = document.getElementById('heartBig');
	var newPath = outline();
	el.querySelector('path').setAttribute('d',newPath);
	el.style.display = "inline-block";
	document.getElementById('heart').style.display = "inline-block";
	let clonedSvgElementB = document.getElementById("heartBig").cloneNode(true);
	var imgB = new Image();
	let clonedSvgElement = document.getElementById("heart").cloneNode(true);
	var img2 = new Image();
	
	imgB.onload = function() {
		ctx.drawImage(img, 0, 0, 300, 300);
		ctx.drawImage(imgB, 0, 0,300,300);
		img2.onload = function() {
			ctx.drawImage(img2, 0, 0,300,300);
		
		}
		
	}
	imgB.src = "data:image/svg+xml;base64," + window.btoa(clonedSvgElementB.outerHTML);
	img2.src = "data:image/svg+xml;base64," + window.btoa(clonedSvgElement.outerHTML);
	
	
}


function parsePath(pd) {
	var pdSplit = pd.toUpperCase().split(/[\s,]+/);
	var points = [];
	var currentMove = 'M';
	var currentPoint = [];
	for (var i=0;i<pdSplit.length;i++){
		if (pdSplit[i] == 'M' || pdSplit[i] == 'C' || pdSplit[i] == 'Q' || pdSplit[i] == 'L' || pdSplit[i] == 'H' || pdSplit[i] == 'V' || pdSplit[i] == 'Z'){
			currentMove = pdSplit[i];
		}
		else if (currentPoint.length == 0) {
			currentPoint.push(Math.round(parseFloat(pdSplit[i])));
			if (currentMove == 'H' || currentMove == 'V') {
				if (currentMove == 'H'){
					points.push({'H':[currentPoint[0]]});
				}
				else if (currentMove == 'V'){
					points.push({'V':[currentPoint[0]]});
				}
				currentPoint = [];
				currentMove == 'L';
			}
		}
		else if (currentMove == 'M' || currentMove == 'L') {
			currentPoint.push(Math.round(parseFloat(pdSplit[i])));
			if (currentMove == 'M'){
					points.push({'M':currentPoint});
				}
				else if (currentMove == 'L'){
					points.push({'L':currentPoint});
				}
			currentPoint = [];
			currentMove == 'L';
		}
		else if (currentMove == 'Q') {
			currentPoint.push(Math.round(parseFloat(pdSplit[i])));
			if (currentPoint.length>=4){
				points.push({'Q':currentPoint});
				currentPoint = [];
				currentMove == 'L';
			}
		}
		else if (currentMove == 'C') {
			currentPoint.push(Math.round(parseFloat(pdSplit[i])));
			if (currentPoint.length>=6){
				points.push({'C':currentPoint});
				currentPoint = [];
				currentMove == 'L';
			}
		}
	}
	return points;
}
function toPath(points){
	var pd = "";
	for (var i=0;i<points.length;i++){
		var key = Object.keys(points[i])[0];
		pd += ' '+key;
		for (var ii=0;ii<points[i][key].length;ii++){
			pd += ' '+points[i][key][ii];
		}
	}
	return pd;
}

function outline(){
	var pd = "M 297.29747,550.86823 C 283.52243,535.43191 249.1268,505.33855 220.86277,483.99412 C 137.11867,420.75228 125.72108,411.5999 91.719238,380.29088 C 29.03471,322.57071 2.413622,264.58086 2.5048478,185.95124 C 2.5493594,147.56739 5.1656152,132.77929 15.914734,110.15398 C 34.151433,71.768267 61.014996,43.244667 95.360052,25.799457 C 119.68545,13.443675 131.6827,7.9542046 172.30448,7.7296236 C 214.79777,7.4947896 223.74311,12.449347 248.73919,26.181459 C 279.1637,42.895777 310.47909,78.617167 316.95242,103.99205 L 320.95052,119.66445 L 330.81015,98.079942 C 386.52632,-23.892986 564.40851,-22.06811 626.31244,101.11153 C 645.95011,140.18758 648.10608,223.6247 630.69256,270.6244 C 607.97729,331.93377 565.31255,378.67493 466.68622,450.30098 C 402.0054,497.27462 328.80148,568.34684 323.70555,578.32901 C 317.79007,589.91654 323.42339,580.14491 297.29747,550.86823 z";
	var points = parsePath(pd);
	console.log(JSON.stringify(points.slice(14)));
	var margin = 100;

	var avgPoints = [];
	var pdPoints = [];
	var ll1 = {'M':[323.70555,578.32901]};
	var ll2 = {'L':[297.29747,550.86823]};
	
	//ll['M']=points[points.length-1][Object.keys(points[points.length-1])[0]];

	var ff2 = {'L':[220.86277,483.99412]};
	var ff3 = {'L':[91.719238,380.29088]};
	//ff['M']=points[0][Object.keys(points[0])[0]];
	points.splice(0,0,ll2);
	points.splice(0,0,ll1);
	points.push(ff2);
	points.push(ff3);
	
	for (var i=1;i<points.length-1;i++){
		var aPoint = {};

		var key = Object.keys(points[i])[0];
		
		var myPoint = points[i][key];
		var last = points[i-1];
		var lastKey = Object.keys(last)[0];
		var next = points[i+1];
		var nextKey = Object.keys(next)[0];
		if (key == 'H' ){
			
			continue;
		}
		else if (key == 'V'){
			
			continue;
		}
		if (lastKey == 'H' ){
			
			continue;
		}
		else if (lastKey == 'V'){
			
			continue;
		}
		if (nextKey == 'H' ){
			
			continue;
		}
		else if (nextKey == 'V'){
			
			continue;
		}
		var lastPoint = [last[lastKey][last[lastKey].length - 2],last[lastKey][last[lastKey].length - 1]];
		var thisPoint = [myPoint[myPoint.length - 2],myPoint[myPoint.length - 1]];
		var nextPoint = [next[nextKey][next[nextKey].length - 2],next[nextKey][next[nextKey].length - 1]];
		
		var d1 = Math.pow( Math.pow((thisPoint[1]-lastPoint[1]),2) + Math.pow((thisPoint[0]-lastPoint[0]),2) ,1);
		var dy1 = margin*Math.pow((thisPoint[1]-lastPoint[1]),2)/d1;
		var dx1 = margin*Math.pow((thisPoint[0]-lastPoint[0]),2)/d1;
		if (thisPoint[1]<lastPoint[1]){
			dy1 *= -1;
		}
		if (thisPoint[0]<lastPoint[0]){
			dx1 *= -1;
		}
			
		dx1 *= -1

		
		d2 = Math.pow( Math.pow((thisPoint[1]-nextPoint[1]),2) + Math.pow((thisPoint[0]-nextPoint[0]),2) ,1);
		dy2 = margin*Math.pow((nextPoint[1]-thisPoint[1]),2)/d2;
		dx2 = margin*Math.pow((nextPoint[0]-thisPoint[0]),2)/d2;
		if (nextPoint[1]<thisPoint[1]){
			dy2 *= -1;
		}
		if (nextPoint[0]<thisPoint[0]){
			dx2 *= -1;
		}
		
		dx2 *= -1
		
		
		var ay = (dy1+dy2)/2;
		var ax = (dx1+dx2)/2;
		var mul = Math.pow(margin,1)/Math.pow((Math.pow(ay,2)+Math.pow(ax,2)),.5);
		
		
		aPoint=[ay*mul,ax*mul];
		
		avgPoints.push(aPoint);
	}
	avgPoints.splice(0,1);
	points.splice(0,1);
	
	for (var i=1;i<points.length-2;i++){
		var aPoint = {};
		var cPoint = {};
		var key = Object.keys(points[i])[0];
		
		var myPoint = points[i][key];
		var last = points[i-1];
		var lastKey = Object.keys(last)[0];
		var next = points[i+1];
		var nextKey = Object.keys(next)[0];
		if (key == 'H' ){
			
			continue;
		}
		else if (key == 'V'){
			
			continue;
		}
		if (lastKey == 'H' ){
			
			continue;
		}
		else if (lastKey == 'V'){
			
			continue;
		}
		if (nextKey == 'H' ){
			
			continue;
		}
		else if (nextKey == 'V'){
			
			continue;
		}
		var lastShift = [avgPoints[i-1][0],avgPoints[i-1][1]];
		var thisShift = [avgPoints[i][0],avgPoints[i][1]];
		
		//lastShift = [0,0];
		//thisShift = [0,0];
		pdPoint = {};
		
		pdPoint[key]=[];
		
		var lastPoint = [last[lastKey][last[lastKey].length - 2],last[lastKey][last[lastKey].length - 1]];
		var thisPoint = [myPoint[myPoint.length - 2],myPoint[myPoint.length - 1]];
		
		var zeroLast = [0,0];
		var zeroThis = [thisPoint[0]-lastPoint[0],thisPoint[1]-lastPoint[1]]; 
		var zeroLastNew = [0,0];
		var zeroThisNew = [thisPoint[0]+thisShift[0]-lastPoint[0]-lastShift[0],thisPoint[1]+thisShift[1]-lastPoint[1]-lastShift[1]]; 
		
		var oldTD = Math.pow(zeroThis[0],2)+Math.pow(zeroThis[1],2);
		var newTD = Math.pow(zeroThisNew[0],2)+Math.pow(zeroThisNew[1],2);
		var ratio = 1;
		if (oldTD != 0){
			ratio = Math.pow(newTD/oldTD,.5);
		}
		
		
		var box = {'bottomLeft':[lastPoint[0],lastPoint[1]],'topLeft':[lastPoint[0]+lastShift[0],lastPoint[1]+lastShift[1]]};
		box['topRight']=[thisPoint[0]+thisShift[0],thisPoint[1]+thisShift[1]];
		box['bottomRight']=[thisPoint[0],thisPoint[1]];
		var fillPath = "M "+lastPoint[0] + " "+lastPoint[1];
		fillPath += " L "+(lastPoint[0]+lastShift[0]) + " "+(lastPoint[1]+lastShift[1]);
		fillPath += " "+key;
		for (var ii=0;ii<myPoint.length/2;ii++){
			var shift = [0,0];
			shift[0] = thisShift[0]*(ii+1)/(myPoint.length/2);
			shift[0] += lastShift[0]*(myPoint.length/2-ii-1)/(myPoint.length/2);
			shift[1] = thisShift[1]*(ii+1)/(myPoint.length/2);
			shift[1] += lastShift[1]*(myPoint.length/2-ii-1)/(myPoint.length/2);
			//pdPoint[key].push([myPoint[2*ii]+shift[0],myPoint[2*ii+1]+shift[1]]);
			//fillPath += " "+(myPoint[2*ii]+shift[0])+" "+(myPoint[2*ii+1]+shift[1]);
			
			
			
			var oldDistance = Math.pow(myPoint[2*ii]-lastPoint[0],2)+Math.pow(myPoint[2*ii+1]-lastPoint[1],2);
			var newDistance = Math.pow(myPoint[2*ii]-lastPoint[0],2)+Math.pow(myPoint[2*ii+1]-lastPoint[1],2);
			var oldD = [myPoint[2*ii]-lastPoint[0],myPoint[2*ii+1]-lastPoint[1]];
			
			var newD = [0,0];
			if (ii >= myPoint.length/2-1){
				if (zeroThis[0] != 0){
					newD[0] = oldD[0]*zeroThisNew[0]/zeroThis[0];
				}
				else {
					newD[0] = oldD[0];
				}
			
				if (zeroThis[1] != 0){
					newD[1] = oldD[1]*zeroThisNew[1]/zeroThis[1];
				}
				else {
					newD[1] = oldD[1];
				}
			}
			else {
				newD[0] = oldD[0]*ratio;
			
			
				newD[1] = oldD[1]*ratio;
			}
			
			
			pdPoint[key].push([newD[0]+lastPoint[0]+lastShift[0],newD[1]+lastPoint[1]+lastShift[1]]);
			fillPath += " "+(newD[0]+lastPoint[0]+lastShift[0])+" "+(newD[1]+lastPoint[1]+lastShift[1]);
			
		}
		
		fillPath += " L "+(thisPoint[0]) + " "+(thisPoint[1]);
		fillPath += " "+key;
		for (var ii=myPoint.length/2-2;ii>=0;ii--){
			
			fillPath += " "+(myPoint[2*ii])+" "+(myPoint[2*ii+1]);
		}
		fillPath += " "+lastPoint[0] + " "+lastPoint[1];
		//console.log(fillPath);
		var heartFill = document.getElementById('heartFill');
		
		
		/*var newDef = document.createElementNS("http://www.w3.org/2000/svg", 'defs');
		var lG = document.createElementNS("http://www.w3.org/2000/svg", 'linearGradient');
		lG.id="box-grad-"+i;
		lG.setAttribute('x1',box['bottomLeft'][0]);
		lG.setAttribute('y1',box['bottomLeft'][1]);
		lG.setAttribute('x2',box['topLeft'][0]);
		lG.setAttribute('y2',box['topLeft'][1]);
		lG.setAttribute('gradientUnits','userSpaceOnUse');
		var newStop = document.createElementNS("http://www.w3.org/2000/svg", 'stop');
		newStop.setAttribute('offset','0%');
		newStop.setAttribute('stop-color','red');
		lG.appendChild(newStop);
		var newStopT = document.createElementNS("http://www.w3.org/2000/svg", 'stop');
		newStopT.setAttribute('offset','100%');
		newStopT.setAttribute('stop-color','blue');
		lG.appendChild(newStopT);
		newDef.appendChild(lG);
		heartFill.appendChild(newDef);*/
		
		
		var newDef = document.createElementNS("http://www.w3.org/2000/svg", 'defs');
		var lG = document.createElementNS("http://www.w3.org/2000/svg", 'radialGradient');
		lG.id="box-grad-"+i;
		var bottomLine = {'m':0,'point':[0,0]};
		var leftLine = {'m':0,'point':[0,0]};
		var rightLine = {'m':0,'point':[0,0]};
		
		if (box['bottomRight'][0]!=box['bottomLeft'][0]){
			bottomLine['m']=(box['bottomRight'][1]-box['bottomLeft'][1])/(box['bottomRight'][0]-box['bottomLeft'][0]);
		}
		else {
			bottomLine['m']=1000;
		}
		if (box['topLeft'][0]!=box['bottomLeft'][0]){
			leftLine['m']=(box['topLeft'][1]-box['bottomLeft'][1])/(box['topLeft'][0]-box['bottomLeft'][0]);
		}
		else {
			leftLine['m']=1000;
		}
		if (box['bottomRight'][0]!=box['topRight'][0]){
			rightLine['m']=(box['bottomRight'][1]-box['topRight'][1])/(box['bottomRight'][0]-box['topRight'][0]);
		}
		else {
			rightLine['m']=1000;
		}
		
		
		
		leftLine['point']=box['bottomLeft'];
		rightLine['point']=box['bottomRight'];
		
		bottomLine['point']=[(box['bottomRight'][0]+box['bottomLeft'][0])/2,(box['bottomRight'][1]+box['bottomLeft'][1])/2];
		
		if (bottomLine['m'] != 0){
			bottomLine['m']=-1/bottomLine['m'];
		}
		else {
			bottomLine['m']=1000;
		}
		
		
		var centerF = lineIntersect(bottomLine,leftLine);
		var curveCenterX = 0;
		var curveCenterY = 0;
		var curveCenterXTop = 0;
		var curveCenterYTop = 0;
		var t = 0.5;
		if (myPoint.length== 6){
			curveCenterX = Math.pow(1-t,3)*lastPoint[0];
			curveCenterX += 3*Math.pow(1-t,2)*t*myPoint[0];
			curveCenterX += 3*Math.pow(t,2)*(1-t)*myPoint[2];
			curveCenterX += Math.pow(t,3)*myPoint[4];
			
			curveCenterXTop = Math.pow(1-t,3)*(lastPoint[0]+lastShift[0]);
			curveCenterXTop += 3*Math.pow(1-t,2)*t*pdPoint[key][0][0];
			curveCenterXTop += 3*Math.pow(t,2)*(1-t)*pdPoint[key][1][0];
			curveCenterXTop += Math.pow(t,3)*pdPoint[key][2][0];
		}
		if (myPoint.length== 6){
			curveCenterY = Math.pow(1-t,3)*lastPoint[1];
			curveCenterY += 3*Math.pow(1-t,2)*t*myPoint[1];
			curveCenterY += 3*Math.pow(t,2)*(1-t)*myPoint[3];
			curveCenterY += Math.pow(t,3)*myPoint[5];
			
			curveCenterYTop = Math.pow(1-t,3)*(lastPoint[1]+lastShift[1]);
			curveCenterYTop += 3*Math.pow(1-t,2)*t*pdPoint[key][0][1];
			curveCenterYTop += 3*Math.pow(t,2)*(1-t)*pdPoint[key][1][1];
			curveCenterYTop += Math.pow(t,3)*pdPoint[key][2][1];
		}
		
		var bigR2 = Math.pow(box['topLeft'][0]-centerF[0],2)+Math.pow(box['topLeft'][1]-centerF[1],2);
		var smallR2 = Math.pow(box['bottomLeft'][0]-centerF[0],2)+Math.pow(box['bottomLeft'][1]-centerF[1],2);
		
		var circleVals = {};
		circleVals.cx = centerF[0];
		circleVals.cy = centerF[1];
		circleVals.fx = centerF[0];
		circleVals.fy = centerF[1];
		circleVals.r = Math.pow(bigR2,.5);
		circleVals.fr = Math.pow(smallR2,.5);
		if (myPoint.length== 6){
			var p1 = {};
			var p2 = {};
			var p3 = {};
			p1.x = box['bottomLeft'][0];
			p1.y = box['bottomLeft'][1];
			p2.x = curveCenterX;
			p2.y = curveCenterY;
			p3.x = box['bottomRight'][0];
			p3.y = box['bottomRight'][1];
			var circle = circleFromThreePoints(p1,p2,p3);
			
			circleVals.fx = circle.x;
			circleVals.fy = circle.y;
			circleVals.fr = circle.r;
			
			var pp1 = {};
			var pp2 = {};
			var pp3 = {};
			pp1.x = box['topLeft'][0];
			pp1.y = box['topLeft'][1];
			pp2.x = curveCenterXTop;
			pp2.y = curveCenterYTop;
			pp3.x = box['topRight'][0];
			pp3.y = box['topRight'][1];
			var circle2 = circleFromThreePoints(pp1,pp2,pp3);
			
			circleVals.cx = circle2.x;
			circleVals.cy = circle2.y;
			circleVals.r = circle2.r;
			
			var z = 1.0;
			while (circleIntersect(circle,circle2,i)){
				var pp1 = {};
				var pp2 = {};
				var pp3 = {};
				z -= 0.1;
				pp1.x = box['topLeft'][0];
				pp1.y = box['topLeft'][1];
				pp2.x = curveCenterXTop*z+(box['topLeft'][0]+box['topRight'][0])/2*(1-z);
				pp2.y = curveCenterYTop*z+(box['topLeft'][1]+box['topRight'][1])/2*(1-z);
				pp3.x = box['topRight'][0];
				pp3.y = box['topRight'][1];
				var circle2 = circleFromThreePoints(pp1,pp2,pp3);
			
				circleVals.cx = circle2.x;
				circleVals.cy = circle2.y;
				circleVals.r = circle2.r;
				if (z<0.2){
					break;
				}
			}
			//console.log(bottomLine,leftLine,centerF,curveCenterX,curveCenterY,curveCenterXTop,curveCenterYTop,circle,circle2,pp1,pp2,pp3);
		}
		
		
		lG.setAttribute('cx',circleVals.cx);
		lG.setAttribute('cy',circleVals.cy);
		lG.setAttribute('fx',circleVals.fx);
		lG.setAttribute('fy',circleVals.fy);
		lG.setAttribute('r',circleVals.r);
		lG.setAttribute('fr',circleVals.fr);
		lG.setAttribute('gradientUnits','userSpaceOnUse');
		var newStop = document.createElementNS("http://www.w3.org/2000/svg", 'stop');
		newStop.setAttribute('offset','0%');
		newStop.setAttribute('stop-color','red');
		newStop.setAttribute('stop-opacity','1.0');
		lG.appendChild(newStop);
		var newStopT = document.createElementNS("http://www.w3.org/2000/svg", 'stop');
		newStopT.setAttribute('offset','100%');
		newStopT.setAttribute('stop-color','red');
		newStopT.setAttribute('stop-opacity','0.0');
		lG.appendChild(newStopT);
		newDef.appendChild(lG);
		heartFill.appendChild(newDef);
		
		var newPath = document.createElementNS("http://www.w3.org/2000/svg", 'path');
		newPath.setAttribute('d',fillPath);
		newPath.style.fill = "url(#box-grad-"+i+")";
		heartFill.appendChild(newPath);
		pdPoints.push(pdPoint);
		
		
	}
	
	var newPd = toPath(pdPoints);
	
	var p1= {'x':2,'y':0};
	var p2= {'x':0,'y':1};
	var c= {'x':0,'y':0};
	getEllipse(p1,p2,c);
	return newPd;
}

function circleIntersect(circle,circle2,i) {
	var dc = Math.pow(circle.x-circle2.x,2)+Math.pow(circle.y-circle2.y,2);
	var dr = Math.abs(circle.r-circle2.r);
	var drp = Math.abs(circle.r+circle2.r);
	if (dr <= Math.pow(dc,.5) && Math.pow(dc,.5) <= drp){
		return true;
	}
	else {
		return false;
	}
	//y*(2*circle2.y-2*circle.y)
	//=
	//Math.pow((x-circle2.x),2)-Math.pow((x-circle.x),2)-Math.pow(circle2.r,2)+Math.pow(circle.r,2)+Math.pow(circle2.y,2)-Math.pow(circle.y,2);
}

function circleFromThreePoints(p1, p2, p3) {

  var x1 = p1.x;
  var y1 = p1.y;
  var x2 = p2.x;
  var y2 = p2.y;
  var x3 = p3.x;
  var y3 = p3.y;

  var a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;

  var b = (x1 * x1 + y1 * y1) * (y3 - y2) 
        + (x2 * x2 + y2 * y2) * (y1 - y3)
        + (x3 * x3 + y3 * y3) * (y2 - y1);
 
  var c = (x1 * x1 + y1 * y1) * (x2 - x3) 
        + (x2 * x2 + y2 * y2) * (x3 - x1) 
        + (x3 * x3 + y3 * y3) * (x1 - x2);
 
  var x = -b / (2 * a);
  var y = -c / (2 * a);

  return {
    x: x,
    y: y,
    r: Math.hypot(x - x1, y - y1)
  };
}

function lineIntersect(line1,line2) {
	var xTop = line1['m']*line1['point'][0] - line2['m']*line2['point'][0] + line2['point'][1]-line1['point'][1];
	var xBottom = line1['m']-line2['m'];
	if (xBottom != 0){
		var x = xTop/xBottom;
		var y = line1['m']*(x-line1['point'][0])+line1['point'][1];
		return [x,y];
	}
	else {
		var x = line1['point'][0];
		var y = line1['m']*(x-line1['point'][0])+line1['point'][1];
		return [x,y];
	}
}
function getEllipse(p1,p2,c){
	var b2Top = Math.pow(p2.y-c.y,2)*Math.pow(p1.x-c.x,2)-Math.pow(p2.x-c.x,2)*Math.pow(p1.y-c.y,2);
	var b2Bottom = Math.pow(p1.x-c.x,2)-Math.pow(p2.x-c.x,2);
	var b2 = b2Top/b2Bottom;
	var b = Math.pow(b2,.5);
	var a2 = Math.pow(p1.x-c.x,2)/(1-(Math.pow(p1.y-c.y,2))/b2);
	var a = Math.pow(a2,.5);
	console.log(a,b);
}

function outlineOld(){
	var pd = "M 297.29747,550.86823 C 283.52243,535.43191 249.1268,505.33855 220.86277,483.99412 C 137.11867,420.75228 125.72108,411.5999 91.719238,380.29088 C 29.03471,322.57071 2.413622,264.58086 2.5048478,185.95124 C 2.5493594,147.56739 5.1656152,132.77929 15.914734,110.15398 C 34.151433,71.768267 61.014996,43.244667 95.360052,25.799457 C 119.68545,13.443675 131.6827,7.9542046 172.30448,7.7296236 C 214.79777,7.4947896 223.74311,12.449347 248.73919,26.181459 C 279.1637,42.895777 310.47909,78.617167 316.95242,103.99205 L 320.95052,119.66445 L 330.81015,98.079942 C 386.52632,-23.892986 564.40851,-22.06811 626.31244,101.11153 C 645.95011,140.18758 648.10608,223.6247 630.69256,270.6244 C 607.97729,331.93377 565.31255,378.67493 466.68622,450.30098 C 402.0054,497.27462 328.80148,568.34684 323.70555,578.32901 C 317.79007,589.91654 323.42339,580.14491 297.29747,550.86823 z";
	var points = parsePath(pd);
	console.log(JSON.stringify(points.slice(14)));
	var margin = 40;
	var newPoints = [];
	var oldPoints = [];
	var avgPoints = [];
	var ll = {'M':[297.29747,550.86823]};
	//ll['M']=points[points.length-1][Object.keys(points[points.length-1])[0]];
	var ff = {'M':[297.29747,550.86823]};
	//ff['M']=points[0][Object.keys(points[0])[0]];
	points.splice(0,0,ll);
	points.push(ff);
	
	for (var i=1;i<points.length-1;i++){
		var aPoint = {};
		var cPoint = {};
		var key = Object.keys(points[i])[0];
		aPoint[key]=[];
		var myPoint = points[i][key];
		var last = points[i-1];
		var lastKey = Object.keys(last)[0];
		var next = points[i+1];
		var nextKey = Object.keys(next)[0];
		if (key == 'H' ){
			
			continue;
		}
		else if (key == 'V'){
			
			continue;
		}
		if (lastKey == 'H' ){
			
			continue;
		}
		else if (lastKey == 'V'){
			
			continue;
		}
		if (nextKey == 'H' ){
			
			continue;
		}
		else if (nextKey == 'V'){
			
			continue;
		}
		var lastPoint = [last[lastKey][last[lastKey].length - 2],last[lastKey][last[lastKey].length - 1]];
		var thisPoint = [myPoint[myPoint.length - 2],myPoint[myPoint.length - 1]];
		var nextPoint = [next[nextKey][next[nextKey].length - 2],next[nextKey][next[nextKey].length - 1]];
		
		var d = Math.pow( Math.pow((thisPoint[1]-lastPoint[1]),2) + Math.pow((thisPoint[0]-lastPoint[0]),2) ,.5);
		var dy = margin*(thisPoint[1]-lastPoint[1])/d;
		var dx = margin*(thisPoint[0]-lastPoint[0])/d;
			
		cPoint[key]=[];
		for (var ii=0;ii<myPoint.length/2;ii++){
			
			
			cPoint[key].push(myPoint[2*ii]+dy);
			cPoint[key].push(myPoint[2*ii+1]-dx);
			//if (i > 15){
			//	console.log('old2:',i,ii,key,d,dx,dy,cPoint[key],lastPoint,myPoint);
			//}
			//lastPoint = [myPoint[2*ii],myPoint[2*ii+1]];
			
		}
		
		d = Math.pow( Math.pow((thisPoint[1]-nextPoint[1]),2) + Math.pow((thisPoint[0]-nextPoint[0]),2) ,.5);
		dy = margin*(nextPoint[1]-thisPoint[1])/d;
		dx = margin*(nextPoint[0]-thisPoint[0])/d;
		
		//lastPoint = [myPoint[0],myPoint[1]];
		var bPoint = {};
		bPoint[key]=[];
		for (var ii=1;ii<myPoint.length/2+1;ii++){
			
			
			

			bPoint[key].push(myPoint[2*ii-2]+dy);
			bPoint[key].push(myPoint[2*ii-1]-dx);
			
			//if (i > 15){
			//	console.log('new',i,ii,key,d,dx,dy,bPoint[key],lastPoint,myPoint);
			//}

			//lastPoint = [myPoint[2*ii],myPoint[2*ii+1]];
			
		}
		
		newPoints.push(cPoint);
		oldPoints.push(bPoint);
		for (var ii=0;ii<cPoint[key].length;ii++){
			aPoint[key].push(Math.round(cPoint[key][ii]*.5+bPoint[key][ii]*.5));
		}
		avgPoints.push(aPoint);
	}
	console.log(JSON.stringify(avgPoints.slice(14)));
	var newPd = toPath(avgPoints);
	return newPd;
}


function selectGroup(){
	isGroup = true;
}

function groupDown() {

}
function groupMove() {

}
function groupUp() {
	isGroup = false;
}
function downloadImage() {
	var url = canvas.toDataURL();
	canvas.toBlob(function(blob) {
	  var burl = URL.createObjectURL(blob);
	  console.log(burl);

	});
	document.getElementById('downloadLink').href = url;
	//console.log(url);
}
</script>
</body>
</html>

