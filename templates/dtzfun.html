<!doctype html>
<html>
<head>
<title>DTZFun</title>
<style>
.game {
	margin: auto;
	width: 60vw;
	height: 60vh;
	left: 20vw;
	top: 20vh;
	position: absolute;
	border: 1px solid black;
}
#borderSVG {
	width: 50vh;
	height: 50vh;
	left: calc(30vw - 25vh);
	top: 5vh;
	position: absolute;
}

</style>

</head>
<body>

<div class="game">
	<svg id="borderSVG" viewBox="-10 -10 120 120" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		
		<circle id="ball-0" cx="50" cy="50" r="3" fill="#CCF" stroke="black" stroke-width="0" />
		<circle id="ball-1" cx="50" cy="20" r="3" fill="#CCF" stroke="black" stroke-width="0" />
		<path id="wall-t" d="" fill="none" stroke="black" stroke-width="1"></path>
	</svg>
</div>

<script>

var svg = document.getElementById("borderSVG");
svg.addEventListener("pointerdown",pdown);
svg.addEventListener("pointermove",pmove);
svg.addEventListener("pointerup",pup);

walls = [{id:"wall-0",v:[[0,0],[0,50],[0,100],[100,100],[90,20],[9,2],[0,0]]}];
nWalls = 0;
addWall(walls[0]);
for (var ii=1;ii<walls[0].v.length;ii++){
	walls[0].v[ii][2]=[0,1];
}

tempWall = {id:"wall-t",v:[],initial:false};
r = 3;
balls = [{id:"ball-0",x:50,y:50,a:-1,el:document.getElementById("ball-0")}];
balls.push({id:"ball-1",x:50,y:20,a:2,el:document.getElementById("ball-1")});
nBalls = 2;
let start;
let old;



function addWall(wall) {
	
	var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.id = wall.id;
	path.setAttributeNS(null,'d',pd);
	path.setAttributeNS(null,'fill',"none");
	path.setAttributeNS(null,'stroke',"red");
	path.setAttributeNS(null,'stroke-width',"1");
	svg.appendChild(path);
	nWalls+=1;
	makeEdgesOne(wall);
}
function updateWall(wall) {
	makeEdgesOne(wall);
	var path = document.getElementById(wall.id);
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function updateTemp() {
	var path = document.getElementById("wall-t");
	var pd = "M";
	for (var ii=0;ii<tempWall.v.length;ii++){
		pd += tempWall.v[ii][0]+","+tempWall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function makeEdgesOne(wall){
	wall.e = [];
	for (var ii=1;ii<wall.v.length;ii++){
		var edge = [];
		if (wall.v[ii][0]-wall.v[ii-1][0] == 0){
			edge.push("inf");
		}
		else {
			edge.push((wall.v[ii][1]-wall.v[ii-1][1])/(wall.v[ii][0]-wall.v[ii-1][0]));
		}
		if (wall.v[ii][1]-wall.v[ii-1][1] == 0){
			edge.push("inf");
		}
		else {
			edge.push(-1*(wall.v[ii][0]-wall.v[ii-1][0])/(wall.v[ii][1]-wall.v[ii-1][1]));
		}
		edge.push(wall.v[ii-1]);
		edge.push(wall.v[ii]);
		edge.push(wall.v[ii][2]);
		wall.e.push(edge);
	}
}
function makeEdges(){
	for (var i=0;i<nWalls;i++){
		makeEdgesOne(walls[i]);
	}
}

function collisionOne(pt,wall,c,i){
	for (var ii=0;ii<wall.e.length;ii++){
		var d = r*r+1;
		if (pt.x < Math.min(wall.e[ii][2][0]-r,wall.e[ii][3][0]-r)) {
			//no collision
		}
		else if (pt.x > Math.max(wall.e[ii][2][0]+r,wall.e[ii][3][0]+r)) {
			//no collision
		}
		else if (pt.y < Math.min(wall.e[ii][2][1]-r,wall.e[ii][3][1]-r)) {
			//no collision
		}
		else if (pt.y > Math.max(wall.e[ii][2][1]+r,wall.e[ii][3][1]+r)) {
			//no collision
		}
		else {
			var pm = wall.e[ii][1];//perpendicular slope of edge
			
			if (pm == "inf"){
				d = Math.pow(wall.e[ii][2][1]-pt.y,2);
			}
			else if (wall.e[ii][0] == "inf"){
				d = Math.pow(wall.e[ii][2][0]-pt.x,2);
			}
			else {
				var xc = (wall.e[ii][2][1]-pt.y+pt.x*pm-wall.e[ii][2][0]*wall.e[ii][0])/(pm-wall.e[ii][0]);
				var yc = pm*(xc-pt.x)+pt.y;
				d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
			}
		}
		//console.log(pt,d);
		if (d<c.d){
			c.wall = i;
			c.edge = ii;
			c.d = d;
		}
	}
	return c;
}

function collision(pt,temp=true){

	var c = {wall:0,edge:0,d:r*r+1};
	
	if (temp && tempWall.initial){
		c = collisionOne(pt,tempWall,c,-1);
		if (c.d <= r*r){
			console.log(c);
			return c;
		}
	}
	for (var i=0;i<nWalls;i++){
		c = collisionOne(pt,walls[i],c,i);
	}

	return c;
}

function move(timestamp) {
	if (!start){
		start = timestamp;
		old = timestamp;
		window.requestAnimationFrame(move);
		return;
	}
	const elapsed = timestamp - old;
	old = timestamp;
	for (var i=0;i<nBalls;i++){
		var x = balls[i].x+Math.cos(balls[i].a)*elapsed/40;
		var y = balls[i].y+Math.sin(balls[i].a)*elapsed/40;
		
		var c = collision({x:x,y:y});
		if (c.d <= r*r){
			if (c.wall == -1){
				console.log("You lose a life!");
				return;
			}
			else {
				var m = walls[c.wall].e[c.edge][0];
				var b = Math.atan(m);
				if (m == "inf"){
					b = Math.PI/2;
				}
				balls[i].a = -1*(2*Math.PI+balls[i].a-2*b);
			}
		}
		balls[i].el.setAttribute("cx",x);
		balls[i].el.setAttribute("cy",y);
		
		balls[i].x = x;
		balls[i].y = y;
	}
	
	
	
	if (timestamp - start < 100000) {
		window.requestAnimationFrame(move);
	}
}

window.requestAnimationFrame(move);

var regions = [{id:0,edges:[[0,0],[0,1],[0,2],[0,3]]}];
function updateRegions(wall,initial,end,oldRegion,newRegion) {
	initial.pt.push([oldRegion,newRegion]);
	end.pt.push([oldRegion,newRegion]);
	var endPoints = [initial.pt,end.pt];
	for (var ii=1;ii<wall.v.length;ii++){
		wall.v[ii][2]=[oldRegion,newRegion];
	}
	if (initial.wall == end.wall){
		if (initial.edge > end.edge){
			walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
			walls[end.wall].v.splice(end.edge+1,0,end.pt);
			makeEdgesOne(walls[initial.wall]);
		}
		else if (initial.edge < end.edge){
			walls[end.wall].v.splice(end.edge+1,0,end.pt);
			walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
			makeEdgesOne(walls[initial.wall]);
		}
		else {
			if (walls[end.wall].v[end.edge][0] < walls[end.wall].v[end.edge+1][0]){
				if (end.pt[0] > initial.pt[0]){ //initial to left of end
					walls[end.wall].v.splice(end.edge+1,0,end.pt);
					walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
					makeEdgesOne(walls[initial.wall]);
				}
				else {
					walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
					walls[end.wall].v.splice(end.edge+1,0,end.pt);
					makeEdgesOne(walls[initial.wall]);
				}
			}
			else {
				if (end.pt[0] > initial.pt[0]){
					walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
					walls[end.wall].v.splice(end.edge+1,0,end.pt);
					makeEdgesOne(walls[initial.wall]);
				}
				else {
					walls[end.wall].v.splice(end.edge+1,0,end.pt);
					walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
					makeEdgesOne(walls[initial.wall]);
				}
			}
		}
	}
	else {
		walls[initial.wall].v.splice(initial.edge+1,0,initial.pt);
		makeEdgesOne(walls[initial.wall]);
		walls[end.wall].v.splice(end.edge+1,0,end.pt);
		makeEdgesOne(walls[initial.wall]);
	}
	
	var newRegionPoints = {'started':false};
	console.log(nWalls);
	var toAssign = {};
	for (var i=0;i<nWalls-1;i++){
		var wall2 = walls[i];
		console.log(wall2);
		for (var ii=0;ii<wall2.v.length-1;ii++){
			if (wall2.v[ii+1][2][0] == oldRegion || wall2.v[ii+1][2][1] == oldRegion){
				var x1 = wall2.e[ii][2][0];
				var y1 = wall2.e[ii][2][1];
				var x2 = wall2.e[ii][3][0];
				var y2 = wall2.e[ii][3][1];
				if (!newRegionPoints.started){
					console.log(x1,y1,x2,y2,initial.pt,end.pt)
					if (x1 == initial.pt[0] && y1 == initial.pt[1]){
						newRegionPoints[x2]={};
						newRegionPoints[x2][y2] = newRegion;
					}
					else if (x1 == end.pt[0] && y1 == end.pt[1]){
						newRegionPoints[x2]={};
						newRegionPoints[x2][y2] = newRegion;
					}
					else if (x2 == initial.pt[0] && y2 == initial.pt[1]){
						newRegionPoints[x1]={};
						newRegionPoints[x1][y1] = newRegion;
					}
					else if (x2 == end.pt[0] && y2 == end.pt[1]){
						newRegionPoints[x1]={};
						newRegionPoints[x1][y1] = newRegion;
					}
					else {
						newRegionPoints[x1]={};
						newRegionPoints[x1][y1] = newRegion;
						if (x1 != x2){
							newRegionPoints[x2]={};
						}
						newRegionPoints[x2][y2] = newRegion;
					}
					newRegionPoints['started']=true;
				}
				else {
					console.log(newRegionPoints[x1],newRegionPoints[x2]);
					if (newRegionPoints[x1] && newRegionPoints[x1][y1]){
						if (x2 == initial.pt[0] && y2 == initial.pt[1]){
						}
						else if (x2 == end.pt[0] && y2 == end.pt[1]){
						}
						else {
							newRegionPoints[x2]={};
							newRegionPoints[x2][y2] = newRegion;
						}
					}
					else if (newRegionPoints[x2] && newRegionPoints[x2][y2]){
						if (x1 == initial.pt[0] && y1 == initial.pt[1]){
						}
						else if (x1 == end.pt[0] && y1 == end.pt[1]){
						}
						else {
							newRegionPoints[x1]={};
							newRegionPoints[x1][y1] = newRegion;
						}
					}
					else {
						if (x1 == initial.pt[0] && y1 == initial.pt[1]){
						}
						else if (x1 == end.pt[0] && y1 == end.pt[1]){
						}
						else if (x2 == initial.pt[0] && y2 == initial.pt[1]){
						}
						else if (x2 == end.pt[0] && y2 == end.pt[1]){
						}
						else {
							if (toAssign[x1]){
								toAssign[x1][y1] = [x2,y2];
							}
							else {
								toAssign[x1] = {};
								toAssign[x1][y1] = [x2,y2];
							}
							if (toAssign[x2]){
								toAssign[x2][y2] = [x1,y1];
							}
							else {
								toAssign[x2] = {};
								toAssign[x2][y2] = [x1,y1];
							}
						}
						
					}
				}
			}
		}
	}
	var moreAssigns = true;
	console.log(toAssign);
	console.log(newRegionPoints);
	while (moreAssigns){
		moreAssigns = false;
		for (var x in toAssign){
			var remy = [];
			for (var y in toAssign[x]){
				if (newRegionPoints[x] && newRegionPoints[x][y]==newRegion){
					if (!newRegionPoints[toAssign[x][y][0]]){
						newRegionPoints[toAssign[x][y][0]] = {};
					}
					newRegionPoints[toAssign[x][y][0]][toAssign[x][y][1]]=newRegion;
					moreAssigns = true;
					remy.push(y);
				}
			}
			for (var i=0;i<remy.length;i++){
				delete toAssign[x][remy[i]];
			}
		}
	}
	console.log(toAssign);
	for (var i=0;i<nWalls-1;i++){
		var wall2 = walls[i];
		for (var ii=0;ii<wall2.v.length-1;ii++){
			if (wall2.v[ii+1][2][0] == oldRegion || wall2.v[ii+1][2][1] == oldRegion){
				var x1 = wall2.e[ii][2][0];
				var y1 = wall2.e[ii][2][1];
				var x2 = wall2.e[ii][3][0];
				var y2 = wall2.e[ii][3][1];
				
				if (newRegionPoints[x1] && !newRegionPoints[x1][y1]){
					if (x1 == initial.pt[0] && y1 == initial.pt[1]){
					}
					else if (x1 == end.pt[0] && y1 == end.pt[1]){
					}
					else {
						newRegionPoints[x1]={};
						newRegionPoints[x1][y1] = oldRegion;
					}
				}
				else if (newRegionPoints[x2] && !newRegionPoints[x2][y2]){
					if (x2 == initial.pt[0] && y2 == initial.pt[1]){
					}
					else if (x2 == end.pt[0] && y2 == end.pt[1]){
					}
					else {
						newRegionPoints[x2]={};
						newRegionPoints[x2][y2] = oldRegion;
					}
				}
			}
		}
	}
	console.log(newRegionPoints);
	console.log(walls);
	
}

function updateTest(){
	walls[0].v[3]=[70,20];
	updateWall(walls[0]);
	
	var newWall = {id:"wall-1",v:[[0,100],[70,20]]};
	walls.push(newWall);
	addWall(newWall);
	
	console.log(nWalls);
	console.log(walls);
	
	start = 0;
	window.requestAnimationFrame(move);
}

isDown = false;
function pdown(evt){
	isDown = true;
	var bcr = evt.currentTarget.getBoundingClientRect();
	var x = Math.round((evt.clientX-bcr.left)/bcr.width*1200 - 100)/10;
	var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
	tempWall.v = [[x,y,0]];
}
function pmove(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*1200 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		tempWall.v.push([x,y,0]);
		var end = cleanWall(tempWall);
		if (tempWall.initial){
			makeEdgesOne(tempWall);
			updateTemp();
		}
		if (end == "end"){
			isDown = false;
			var newWall = {id:"wall-"+nWalls,v:tempWall.v};
			walls.push(newWall);
			console.log(newWall);
			console.log(walls);
			addWall(newWall);
			var oldRegion = 1;
			var newRegion = 2;
			updateRegions(newWall,tempWall.initial,tempWall.end,oldRegion,newRegion);
			
			tempWall.v = [];
			tempWall.e = [];
			tempWall.initial = false;
			
		}
	}
}
function pup(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*1200 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		//tempWall.v.push([x,y,0]);
		console.log(tempWall);
		isDown = false;
		
		/*var newWall = {id:"wall-"+nWalls,v:tempWall.v};
		walls.push(newWall);
		addWall(newWall);
		tempWall.v = [];
		tempWall.e = [];
		tempWall.initial = false;*/
		
		
	}
}

function collisionPoint(line1,line2){
	if (line1.m == "inf"){
		line1.m = 1000;
	}
	if (line2.m == "inf"){
		line2.m = 1000;
	}
	if (line1.m == line2.m){
		return [line1.pt.x,line1.pt.y];
	}
	var xc = (line2.pt.y-line1.pt.y+line1.pt.x*line1.m-line2.pt.x*line2.m)/(line1.m-line2.m);
	var yc = line1.m*(xc-line1.pt.x)+line1.pt.y;
	console.log(line1,line2,xc,yc);
	return [xc,yc];
}

function cleanWall(wall){

	if (!wall.initial){
		for (var ii=0;ii<wall.v.length;ii++){
			var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
			var c = collision(pt);
			if (c.d <= r*r){
				//set to intersection point
				wall.v.splice(0,ii);
				
				var m1 = walls[c.wall].e[c.edge][1];
				var m2 = walls[c.wall].e[c.edge][0];
				var line1 = {pt:{x:pt.x,y:pt.y},m:m1};
				var line2 = {pt:{x:walls[c.wall].e[c.edge][2][0],y:walls[c.wall].e[c.edge][2][1]},m:m2};
				var pc = collisionPoint(line1,line2);
				wall.v[0][0] = pc[0]; 
				wall.v[0][1] = pc[1];
				wall.initial = {wall:c.wall,edge:c.edge,pt:pc};
				return;
				break;
			}
		}
	}
	else {// look for end
		var totald = 0;
		for (var ii=1;ii<wall.v.length;ii++){
			if (wall.v[ii][2] == 0){
				var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
				var d = Math.pow(pt.x-wall.v[ii-1][0],2)+Math.pow(pt.y-wall.v[ii-1][1],2);
				wall.v[ii][2] = d;
				totald += d;
				if (totald > r*r*2){
					var c = collision(pt,false);
					if (c.d <= r*r){
						wall.v[ii][2] = -1;
						var m1 = walls[c.wall].e[c.edge][1];
						var m2 = walls[c.wall].e[c.edge][0];
						var line1 = {pt:{x:pt.x,y:pt.y},m:m1};
						var line2 = {pt:{x:walls[c.wall].e[c.edge][2][0],y:walls[c.wall].e[c.edge][2][1]},m:m2};
						var pc = collisionPoint(line1,line2);
						wall.end = {wall:c.wall,edge:c.edge,pt:pc};
						wall.v[ii][0] = pc[0]; 
						wall.v[ii][1] = pc[1];
						wall.v = wall.v.slice(0,ii+1);
						console.log("end");
						return "end";
					}
				}
			}
			else if (wall.v[ii][2] > 0){
				totald += wall.v[ii][2];
			}
		}
	}
	for (var ii=1;ii<wall.v.length-1;ii++){
		//var d = Math.pow(wall.v[ii][0]-wall.v[ii-1][0],2)+Math.pow(wall.v[ii][1]-wall.v[ii-1][1],2);
		var d = wall.v[ii][2];
		if (d <= 0){
			d = Math.pow(wall.v[ii][0]-wall.v[ii-1][0],2)+Math.pow(wall.v[ii][1]-wall.v[ii-1][1],2);
		}
		if (d > 0 && d < 9){
			
			wall.v[ii+1][2]=Math.pow(wall.v[ii-1][0]-wall.v[ii+1][0],2)+Math.pow(wall.v[ii-1][1]-wall.v[ii+1][1],2);
			
			wall.v.splice(ii,1);
			ii--;
		}
	}
	//console.log(wall.v);
}
</script>
</body>
</html>