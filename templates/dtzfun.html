<!doctype html>
<html>
<head>
<title>DTZFun</title>
<style>
.game {
	margin: auto;
	width: 90vw;
	height: 85vh;
	left: 5vw;
	top: 7.5vh;
	position: absolute;
	border: 1px solid black;
	touch-action: none;
}
img {
	width: 160vh;
	height: 80vh;
	left: calc(45vw - 160vh / 2);
	top: 2.5vh;
	position: absolute;
}
#borderSVG {
	width: calc({{ width + 20 }} / 120 * 80vh);
	height: 80vh;
	left: calc(45vw - calc({{ width + 20 }} / 120 * 80vh) / 2);
	top: 2.5vh;
	position: absolute;
}

</style>

</head>
<body>
<button onclick="showInfo()">Show</button>
<button onclick="nextRound()">Next</button>
<span> Pct: </span>
<span id="pctDone">0</span>
<span> (</span>
<span id="pctNeeded">70</span>
<span>) </span>
<span> Lives: </span>
<span id="lives">3</span>
<span> Points: </span>
<span id="points">0</span>
<div class="game">
	<img src="img/lemur.jpg">
	<svg id="borderSVG" viewBox="-10 -10 {{ width + 20 }} 120" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

		<path id="wall-t" d="" fill="white" stroke="black" stroke-width="1"></path>
	</svg>
</div>

<script src="js/postfix.js"></script>
<script>

winpct = 70;
var maxTime = 1000000;
var outlineWall = {{ bigwall | dump | safe }};
var svg = document.getElementById("borderSVG");
var pctEl = document.getElementById("pctDone");
var ptEl = document.getElementById("points");
var pctNEl = document.getElementById("pctNeeded");
var livesEl = document.getElementById("lives");
svg.addEventListener("pointerdown",pdown);
svg.addEventListener("pointermove",pmove);
svg.addEventListener("pointerup",pup);


r = 2;
var lives = 2;
var walls;
nWalls = 0;
balls = [];
nBalls = 3;
var level = 0;
var pointTotal = 0;
var pointData = {t:0,r0:0,r1:0,r2:0,r:1,d:0,v:0,c:0};
isDown = false;
kill = false;

var filledArea = 0;
var totalArea = 0;
var showAll = false;

tempWall = {id:"wall-t",v:[],initial:false};

var start;
var old;

resetGame(level);

function resetGame(level){
	nBalls = level+3;
	lives = Math.min(lives+1,7);
	//var speedFormula = 15*Math.random()+Math.max(15,30-l);
	winpct = Math.max(50,75-level);
	
	
	if (level > 0){
		pointTotal += 1000*(pointData.c-pointData.v/2)/(pointData.r0+1)/Math.log(pointData.d+3)/Math.log(pointData.t+3)
		var pt = solvePostfix("##+","2,c",pointData);
		console.log(pointData.c,pt);
		ptEl.textContent = pointTotal;
	}
	pctNEl.textContent = winpct;
	livesEl.textContent = lives;
	pointData = {t:0,r0:0,r1:0,r2:0,r:1,d:0,v:winpct,c:0};
	
	
	svg.innerHTML = '<path id="wall-t" d="" fill="white" stroke="black" stroke-width="1"></path>';
	pctEl.textContent = "0";
	r = 2;
	walls = [{id:"wall-0",balls:[],v:outlineWall}];
	nWalls = 0;
	addWall(walls[0],true);
	removeLoops(walls[0]);
	updateWall(walls[0]);
	balls = [];
	
	for (var i=0;i<nBalls;i++){
		var rand = Math.random();
		//var speed = 15*rand+Math.max(15,30-level);
		var speed = solvePostfix("{{ speed[0] }}","{{speed[1]}}",{l:level});
		console.log(level,speed);
		addBall(i,speed);
	}
	isDown = false;

	filledArea = 0;
	totalArea = area(walls[0].v);
	showAll = false;



	tempWall = {id:"wall-t",v:[],initial:false};

	start = 0;
	old = 0;
	kill = false;
	window.requestAnimationFrame(move);
	
}

function addBall(bid,s) {
	walls[0].balls.push(bid);
	var x = Math.round(Math.random()*{{ width }});
	var y = Math.round(Math.random()*100);
	var a = Math.random()*2*Math.PI;
	var region = ballRegion([x,y],-1,[0]);
	var cc = {wall:0,edge:0,d:r*r+1};
	var c = collisionOne({x:x,y:y},walls[0],cc,0);
	if (c.d <= r*r){
		region = -1;
	}
	var counter = 0;
	while (region == -1){
		x = Math.round(Math.random()*{{ width }});
		y = Math.round(Math.random()*100);
		region = ballRegion([x,y],-1,[0]);
		var cc = {wall:0,edge:0,d:r*r+1};
		var c = collisionOne({x:x,y:y},walls[0],cc,0);
		if (c.d <= r*r){
			console.log(c);
			region = -1;
		}
		counter++;
		if (counter > 10){
			console.log("no luck placing balls in region");
			break;
		}
	}
	
	var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	circle.id = "ball-"+bid;
	circle.setAttributeNS(null,'cx',x);
	circle.setAttributeNS(null,'cy',y);
	circle.setAttributeNS(null,'r',r);
	circle.setAttributeNS(null,'fill',"#CCF");
	circle.setAttributeNS(null,'stroke',"red");
	circle.setAttributeNS(null,'stroke-width',"0.1");
	svg.appendChild(circle);
	balls.push({id:"ball-"+bid,region:0,x:x,y:y,a:a,s:s,el:document.getElementById("ball-"+bid)});

}

function addWall(wall,outline=false) {
	
	var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.id = wall.id;
	path.setAttributeNS(null,'d',pd);
	path.setAttributeNS(null,'fill',"white");
	path.setAttributeNS(null,'stroke',"red");
	path.setAttributeNS(null,'stroke-width',"1");
	var wt = document.getElementById("wall-t");
	svg.insertBefore(path,wt);
	nWalls+=1;
	makeEdgesOne(wall);
	if (outline){
		var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
		var pd = "M";
		for (var ii=0;ii<wall.v.length;ii++){
			pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
		}
		path.id = "outline";
		path.setAttributeNS(null,'d',pd);
		path.setAttributeNS(null,'fill',"none");
		path.setAttributeNS(null,'stroke',"red");
		path.setAttributeNS(null,'stroke-width',"1");
		var wt = document.getElementById("wall-t");
		svg.insertBefore(path,wt);
	}
}
function updateWall(wall) {
	makeEdgesOne(wall);
	var path = document.getElementById(wall.id);
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function updateTemp() {
	var path = document.getElementById("wall-t");
	var pd = "M";
	if (tempWall.v.length == 0){
		pd += "0,0";
	}
	for (var ii=0;ii<tempWall.v.length;ii++){
		pd += tempWall.v[ii][0]+","+tempWall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function makeEdgesOne(wall){
	wall.e = [];
	for (var ii=1;ii<wall.v.length;ii++){
		var edge = [];
		if (wall.v[ii][0]-wall.v[ii-1][0] == 0){
			edge.push("inf");
		}
		else {
			edge.push((wall.v[ii][1]-wall.v[ii-1][1])/(wall.v[ii][0]-wall.v[ii-1][0]));
		}
		if (wall.v[ii][1]-wall.v[ii-1][1] == 0){
			edge.push("inf");
		}
		else {
			edge.push(-1*(wall.v[ii][0]-wall.v[ii-1][0])/(wall.v[ii][1]-wall.v[ii-1][1]));
		}
		edge.push(wall.v[ii-1]);
		edge.push(wall.v[ii]);
		wall.e.push(edge);
	}
}
function makeEdges(){
	for (var i=0;i<nWalls;i++){
		makeEdgesOne(walls[i]);
	}
}

function dPtEdge(pt,edge){
	var pm = edge[1];//perpendicular slope of edge
	var d;
	if (pm == "inf"){
		d = Math.pow(edge[2][1]-pt.y,2);
	}
	else if (edge[0] == "inf"){
		d = Math.pow(edge[2][0]-pt.x,2);
	}
	else {
		var xc = (edge[2][1]-pt.y+pt.x*pm-edge[2][0]*edge[0])/(pm-edge[0]);
		var yc = pm*(xc-pt.x)+pt.y;
		d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
	}
	return d;
}
function collisionOne(pt,wall,c,i){
	for (var ii=0;ii<wall.e.length;ii++){
		var d = r*r+1;
		if (pt.x < Math.min(wall.e[ii][2][0]-r,wall.e[ii][3][0]-r)) {
			//no collision
		}
		else if (pt.x > Math.max(wall.e[ii][2][0]+r,wall.e[ii][3][0]+r)) {
			//no collision
		}
		else if (pt.y < Math.min(wall.e[ii][2][1]-r,wall.e[ii][3][1]-r)) {
			//no collision
		}
		else if (pt.y > Math.max(wall.e[ii][2][1]+r,wall.e[ii][3][1]+r)) {
			//no collision
		}
		else {
			var pm = wall.e[ii][1];//perpendicular slope of edge
			
			if (pm == "inf"){
				d = Math.pow(wall.e[ii][2][1]-pt.y,2);
			}
			else if (wall.e[ii][0] == "inf"){
				d = Math.pow(wall.e[ii][2][0]-pt.x,2);
			}
			else {
				var xc = (wall.e[ii][2][1]-pt.y+pt.x*pm-wall.e[ii][2][0]*wall.e[ii][0])/(pm-wall.e[ii][0]);
				var yc = pm*(xc-pt.x)+pt.y;
				d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
			}
		}
		//console.log(pt,d);
		if (d<c.d){
			c.wall = i;
			c.edge = ii;
			c.d = d;
		}
	}
	return c;
}

function collision(pt,wid=-1){

	var c = {wall:0,edge:0,d:r*r+1};
	
	if (tempWall.initial){
		c = collisionOne(pt,tempWall,c,-1);
		if (c.d <= r*r){
			console.log(c);
			return c;
		}
	}
	if (wid==-1){
		for (var i=0;i<nWalls;i++){
			c = collisionOne(pt,walls[i],c,i);
		}
	}
	else {
		c = collisionOne(pt,walls[wid],c,wid);
	}

	return c;
}

function loseLife() {
	console.log("You lose a life!");
	lives--;
	pointData.d++;
	if (lives < 0){
		kill = true;
	}
	else {
		livesEl.textContent = lives;
		isDown = false;
		
		tempWall.v = [];
		tempWall.e = [];
		tempWall.initial = false;
		updateTemp();
	}
}
function move(timestamp) {
	if (kill){
		pointData.t=timestamp-start;
		return;
	}
	if (!start){
		start = timestamp;
		old = timestamp;
		window.requestAnimationFrame(move);
		return;
	}
	const elapsed = timestamp - old;
	old = timestamp;
	for (var i=0;i<nBalls;i++){
		var x = balls[i].x+Math.cos(balls[i].a)*elapsed*balls[i].s/1000;
		var y = balls[i].y+Math.sin(balls[i].a)*elapsed*balls[i].s/1000;
		var wid = balls[i].region;
		var c = collision({x:x,y:y},wid);
		if (c.d <= r*r){
			if (c.wall == -1){//hit temp Wall
				loseLife();
			}
			else {//hit real Wall
				var m = walls[c.wall].e[c.edge][0];
				if (showAll){
					console.log(m,Math.atan(m),balls[i].a);
				}
				var b = Math.atan(m);
				if (m == "inf"){
					b = Math.PI/2;
					balls[i].a = -1*(2*Math.PI+balls[i].a-2*b);
				}
				else {
					balls[i].a = -1*(2*Math.PI+balls[i].a-2*b);
					var d = dPtEdge({x:x,y:y},walls[c.wall].e[c.edge]);
					var dd = dPtEdge({x:x+Math.cos(balls[i].a)*elapsed/40,y:y+Math.sin(balls[i].a)*elapsed/40},walls[c.wall].e[c.edge]);
					if (dd < d){
						balls[i].a = Math.PI/4+balls[i].a;
					}
				}
				if (showAll){
					console.log(x,y,balls[i].x,balls[i].y,m,Math.atan(m),balls[i].a);
				}
				if (balls[i].a > 2*Math.PI){
					balls[i].a -= 2*Math.PI;
				}
				else if (balls[i].a < -2*Math.PI){
					balls[i].a += 2*Math.PI;
				}
				balls[i].a += -0.25 + Math.random()*0.5;
				
				var chk = ballRegion([x,y],i,[balls[i].region]);
				var counter = 0;
				var xx = x; var yy = y;
				while (chk !== balls[i].region){
					xx = x - Math.log(counter+3)/2+ Math.random()*Math.log(counter+3);
					yy = y - Math.log(counter+3)/2+ Math.random()*Math.log(counter+3);
					chk = ballRegion([xx,yy],i,[balls[i].region]);
					
					counter++;
					if (counter > 10){
						console.log("escaping",chk,balls[i].region);
						break;
					}
				}
				x = xx; y = yy;
			}
		}
		
		
		balls[i].el.setAttribute("cx",x);
		balls[i].el.setAttribute("cy",y);
		
		balls[i].x = x;
		balls[i].y = y;
	}
	
	
	
	if (timestamp - start < maxTime) {
		window.requestAnimationFrame(move);
	}
}



function ballRegion(pt,bid,myWalls=false){
	let dp = svg.createSVGPoint();
	dp.x = pt[0];
	dp.y = pt[1];
	if (!myWalls){
		for (var i=0;i<nWalls;i++){
			var el = document.getElementById(walls[i].id);
			var isInside = el.isPointInFill(dp);
			console.log(i,isInside);
			if (isInside){
				balls[bid].region=i;
				return i;
				break;
			}
		}
	}
	else {
		for (var i=0;i<myWalls.length;i++){
			var wid = myWalls[i];
			var el = document.getElementById(walls[wid].id);
			var isInside = el.isPointInFill(dp);
			if (isInside){
				if (bid >= 0){
					balls[bid].region=wid;
					return wid;
				}
				else {
					return wid;
				}
				break;
			}
		}
	}
	return -1;
}
function area(polygon) {
    let total = 0;
    for (let i = 0; i < polygon.length; i++) {
        const addX = polygon[i][0];
        const addY = polygon[i === polygon.length - 1 ? 0 : i + 1][1];
        const subX = polygon[i === polygon.length - 1 ? 0 : i + 1][0];
        const subY = polygon[i][1];
        total += (addX * addY * 0.5) - (subX * subY * 0.5);
    }
    return Math.abs(total);
}

function updateRegions(wall,initialArr,endArr) {
	
	
	var initial = initialArr[0];
	var end = endArr[0];
	var isWall = false;
	console.log(initialArr,endArr);
	for (var i=0;i<initialArr.length;i++){
		for (var ii=0;ii<endArr.length;ii++){
			console.log(initialArr[i].wall,endArr[ii].wall);
			if (initialArr[i].wall == endArr[ii].wall){
				initial = initialArr[i];
				end = endArr[ii];
				i = initialArr.length + 10;
				if (walls[initial.wall].balls.length == 0){
					return;
				}
				isWall = true;
				break;
			}
		}
	}
	if (isWall){
		walls.push(wall);
		addWall(wall);
	}
	else {
		return;
	}
	
	var leftWall = {v:[]};
	var rightWall = {v:[]};
	end.pt[0] = Math.round(end.pt[0]*10)/10;
	end.pt[1] = Math.round(end.pt[1]*10)/10;
	initial.pt[0] = Math.round(initial.pt[0]*10)/10;
	initial.pt[1] = Math.round(initial.pt[1]*10)/10;
	if (initial.wall == end.wall){
		if (initial.edge > end.edge){
			leftWall.v = walls[initial.wall].v.slice(0,end.edge+1);
			for (var ii=wall.v.length-1;ii>=0;ii--){
				var x = Math.round(wall.v[ii][0]*10)/10;
				var y = Math.round(wall.v[ii][1]*10)/10;
				leftWall.v.push([x,y]);
			}
			for (var ii=initial.edge+1;ii<walls[initial.wall].v.length;ii++){
				leftWall.v.push(walls[initial.wall].v[ii]);
			}
			
			rightWall.v = walls[initial.wall].v.slice(end.edge+1,initial.edge+1);
			rightWall.v.splice(0,0,end.pt);
			for (var ii=0;ii<wall.v.length;ii++){
				var x = Math.round(wall.v[ii][0]*10)/10;
				var y = Math.round(wall.v[ii][1]*10)/10;
				rightWall.v.push([x,y]);
			}
		}
		else if (initial.edge < end.edge){
			leftWall.v = walls[initial.wall].v.slice(0,initial.edge+1);
			for (var ii=0;ii<wall.v.length;ii++){
				var x = Math.round(wall.v[ii][0]*10)/10;
				var y = Math.round(wall.v[ii][1]*10)/10;
				leftWall.v.push([x,y]);
			}
			for (var ii=end.edge+1;ii<walls[initial.wall].v.length;ii++){
				leftWall.v.push(walls[initial.wall].v[ii]);
			}
			
			rightWall.v = walls[initial.wall].v.slice(initial.edge+1,end.edge+1);
			rightWall.v.splice(0,0,initial.pt);
			for (var ii=wall.v.length-1;ii>=0;ii--){
				var x = Math.round(wall.v[ii][0]*10)/10;
				var y = Math.round(wall.v[ii][1]*10)/10;
				rightWall.v.push([x,y]);
			}
		}
		else {
			
		}
	}
	if (leftWall.v.length < 2 || rightWall.v.length < 2){
		walls.pop();
		nWalls--;
		return;
	}
	var oldBalls = walls[initial.wall].balls;
	
	walls[initial.wall].v = leftWall.v;
	updateWall(walls[initial.wall]);
	walls[nWalls-1].v = rightWall.v;
	updateWall(walls[nWalls-1]);
	
	walls[initial.wall].balls = [];
	walls[nWalls-1].balls = [];
	for (var i=0;i<oldBalls.length;i++){
		var bid = oldBalls[i];
		var pt = [balls[bid].x,balls[bid].y];
		ballRegion(pt,bid,[initial.wall,nWalls-1]);
		if (balls[bid].region==nWalls-1){
			walls[nWalls-1].balls.push(bid);
		}
		else {
			walls[initial.wall].balls.push(bid);
		}
	}
	if (walls[initial.wall].balls.length == 0){
		var path = document.getElementById("wall-"+initial.wall);
		path.setAttributeNS(null,'fill',"none");
		path.setAttributeNS(null,'stroke',"none");
		filledArea += area(walls[initial.wall].v);
		pointData.r0++;
	}
	else if (walls[nWalls-1].balls.length == 0){
		var path = document.getElementById("wall-"+(nWalls-1));
		path.setAttributeNS(null,'fill',"none");
		path.setAttributeNS(null,'stroke',"none");
		filledArea += area(walls[nWalls-1].v);
		pointData.r0++;
	}
	pointData.r++;
	console.log(filledArea,totalArea,filledArea*100/totalArea);
	pctEl.textContent = Math.round(filledArea*1000/totalArea)/10;
	if (filledArea*100/totalArea > winpct){
		pointData.c = filledArea*100/totalArea;
		kill = true;
	}
}

function nextRound(){
	level++;
	resetGame(level);
}
function showInfo(){
	showAll = true;
	start = 0;
	maxTime = 1000;
}
function updateTest(){

	start = 0;
	window.requestAnimationFrame(move);
}


function pdown(evt){
	isDown = true;
	var bcr = evt.currentTarget.getBoundingClientRect();
	var x = Math.round((evt.clientX-bcr.left)/bcr.width*{{ width + 20 }}*10 - 100)/10;
	var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
	tempWall.v = [[x,y,0]];
}
function removeLoops(wall){
	makeEdgesOne(wall);
	var lines = {};
	for (var i=0;i<wall.e.length;i++){
		var line1 = {pt:{x:wall.e[i][2][0],y:wall.e[i][2][1]},m:wall.e[i][0]};
		lines[i]=line1;
	}
	for (var i=0;i<wall.e.length-1;i++){
		
		var line1 = lines[i];
										
		for (var ii=1;ii<i-1;ii++){
			var line2 = lines[ii];

			var pc = collisionPoint(line1,line2);
			var bothInt = 0;
			if (pc[0]<=wall.e[i][2][0] && pc[0]>=wall.e[i][3][0]){
				bothInt++;
			}
			else if (pc[0]<=wall.e[i][3][0] && pc[0]>=wall.e[i][2][0]){
				bothInt++;
			}
			if (pc[0]<=wall.e[ii][2][0] && pc[0]>=wall.e[ii][3][0]){
				bothInt++;
			}
			else if (pc[0]<=wall.e[ii][3][0] && pc[0]>=wall.e[ii][2][0]){
				bothInt++;
			}
			if (pc[1]<=wall.e[i][2][1] && pc[1]>=wall.e[i][3][1]){
				bothInt++;
			}
			else if (pc[1]<=wall.e[i][3][1] && pc[1]>=wall.e[i][2][1]){
				bothInt++;
			}
			if (pc[1]<=wall.e[ii][2][1] && pc[1]>=wall.e[ii][3][1]){
				bothInt++;
			}
			else if (pc[1]<=wall.e[ii][3][1] && pc[1]>=wall.e[ii][2][1]){
				bothInt++;
			}
			if (bothInt == 4){
				
				var dd = 0;
				var td = 0;
				for (var iii=0;iii<wall.e.length;iii++){
					td += Math.pow( Math.pow(wall.v[iii+1][0]-wall.v[iii][0],2)+Math.pow(wall.v[iii+1][1]-wall.v[iii][1],2) , 0.5);
					if (iii >= ii && iii < i){
						dd += Math.pow( Math.pow(wall.v[iii+1][0]-wall.v[iii][0],2)+Math.pow(wall.v[iii+1][1]-wall.v[iii][1],2) , 0.5);
					
					}
				}
				if (dd > td/2){
					wall.v = wall.v.slice(ii,i);
				}
				else {
					wall.v.splice(ii,i-ii);
				}
				console.log(wall.e.length,i,ii,dd,td,wall.e[i],wall.e[ii],line1,line2,pc);
				removeLoops(wall);
				return;
			}
			
		}
	}
}
function pmove(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*{{ width + 20 }}*10 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		tempWall.v.push([x,y,0]);
		var end = cleanWall(tempWall);
		if (tempWall.initial){
			makeEdgesOne(tempWall);
			updateTemp();
		}
		if (end == "end"){
			isDown = false;
			var ret = findStart(tempWall,true);
			removeLoops(tempWall);
			var newWall = {id:"wall-"+nWalls,v:tempWall.v};
			
			updateRegions(newWall,tempWall.initial,tempWall.end);
			
			tempWall.v = [];
			tempWall.e = [];
			tempWall.initial = false;
			updateTemp();
			
		}
	}
}
function pup(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*{{ width + 20 }}*10 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		//tempWall.v.push([x,y,0]);
		console.log(tempWall);
		isDown = false;
		
		
		tempWall.v = [];
		tempWall.e = [];
		tempWall.initial = false;
		updateTemp();
		
		
	}
}

function collisionPoint(line1,line2){
	if (line1.m == "inf"){
		line1.m = 1000;
	}
	if (line2.m == "inf"){
		line2.m = 1000;
	}
	if (line1.m == line2.m){
		return [line1.pt.x,line1.pt.y];
	}
	var xc = (line2.pt.y-line1.pt.y+line1.pt.x*line1.m-line2.pt.x*line2.m)/(line1.m-line2.m);
	var yc = line1.m*(xc-line1.pt.x)+line1.pt.y;
	return [xc,yc];
}

function findStart(wall,lastHit=false){
	var hits = [];
	for (var ii=0;ii<wall.v.length;ii++){
		var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
		var cc = {wall:0,edge:0,d:r*r+1};
		var wcs = [];
		for (var i=0;i<nWalls;i++){
			cc = {wall:0,edge:0,d:r*r+1};
			var c = collisionOne(pt,walls[i],cc,i);
			if (c.d <= r*r){
				wcs.push(c);
				console.log(c.wall);
				console.log(JSON.stringify(cc));
			}
		}
		if (wcs.length > 0){
			if (lastHit){
				hits.push(ii);
			}
			else {
				//set to intersection point
			
				wall.v.splice(0,ii);
				wall.initial = [];
				for (var i=0;i<wcs.length;i++){
					var c = wcs[i];
					var m1 = walls[c.wall].e[c.edge][1];
					var m2 = walls[c.wall].e[c.edge][0];
					var line1 = {pt:{x:pt.x,y:pt.y},m:m1};
					var line2 = {pt:{x:walls[c.wall].e[c.edge][2][0],y:walls[c.wall].e[c.edge][2][1]},m:m2};
					var pc = collisionPoint(line1,line2);
					wall.v[0][0] = pc[0]; 
					wall.v[0][1] = pc[1];
					wall.initial.push({wall:c.wall,edge:c.edge,pt:pc});
				}
				return 1;
			}
		}
	}
	if (lastHit){
		console.log(hits);
		var ii = hits[0];
		if (hits.length > 1){
			ii = hits[hits.length-2];
		}
		console.log(ii);
		var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
		var cc = {wall:0,edge:0,d:r*r+1};
		var wcs = [];
		for (var i=0;i<nWalls;i++){
			cc = {wall:0,edge:0,d:r*r+1};
			var c = collisionOne(pt,walls[i],cc,i);
			if (c.d <= r*r){
				wcs.push(c);
			}
		}
		wall.v.splice(0,ii);
		wall.initial = [];
		for (var i=0;i<wcs.length;i++){
			var c = wcs[i];
			var m1 = walls[c.wall].e[c.edge][1];
			var m2 = walls[c.wall].e[c.edge][0];
			var line1 = {pt:{x:pt.x,y:pt.y},m:m1};
			var line2 = {pt:{x:walls[c.wall].e[c.edge][2][0],y:walls[c.wall].e[c.edge][2][1]},m:m2};
			var pc = collisionPoint(line1,line2);
			wall.v[0][0] = pc[0]; 
			wall.v[0][1] = pc[1];
			wall.initial.push({wall:c.wall,edge:c.edge,pt:pc});
		}
		return 1;

	}
}
function cleanWall(wall){

	if (!wall.initial){
		var ret = findStart(wall);
		if (ret == 1){
			return;
		}
	}
	else {// look for end
		var totald = 0;
		for (var ii=1;ii<wall.v.length;ii++){
			if (wall.v[ii][2] == 0){
				var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
				var d = Math.pow(pt.x-wall.v[ii-1][0],2)+Math.pow(pt.y-wall.v[ii-1][1],2);
				wall.v[ii][2] = d;
				totald += d;
				if (totald > r*r*4){
					var cc = {wall:0,edge:0,d:r*r+1};
					var wcs = [];
					for (var i=0;i<nWalls;i++){
						cc = {wall:0,edge:0,d:r*r+1};
						var c = collisionOne(pt,walls[i],cc,i);
						if (c.d <= r*r){
							for (var iii=0;iii<wall.initial.length;iii++){
								if (wall.initial[iii].wall == c.wall){
									var dd = 0;
									var td = 0;
									for (var iv=0;iv<walls[c.wall].v.length-1;iv++){
										td += Math.pow( Math.pow(walls[c.wall].v[iv+1][0]-walls[c.wall].v[iv][0],2)+Math.pow(walls[c.wall].v[iv+1][1]-walls[c.wall].v[iv][1],2) , 0.5);
									}
									if (c.edge < wall.initial[iii].edge){
										for (var iv=c.edge;iv<wall.initial[iii].edge;iv++){
											dd += Math.pow( Math.pow(walls[c.wall].v[iv+1][0]-walls[c.wall].v[iv][0],2)+Math.pow(walls[c.wall].v[iv+1][1]-walls[c.wall].v[iv][1],2) , 0.5);
										}
									}
									else if (c.edge > wall.initial[iii].edge){
										for (var iv=wall.initial[iii].edge;iv<c.edge;iv++){
											dd += Math.pow( Math.pow(walls[c.wall].v[iv+1][0]-walls[c.wall].v[iv][0],2)+Math.pow(walls[c.wall].v[iv+1][1]-walls[c.wall].v[iv][1],2) , 0.5);
										}
									}
									if (dd > 3*r && td-dd > 3*r){
										wcs.push(c);
										break;
									}
									else {
										console.log("not enough distance on edge",dd,td,c.edge,wall.initial[iii].edge);
									}
								}
							}
							
						}
					}
					if (wcs.length > 0){
						//set to intersection point
						wall.v[ii][2] = -1;
						wall.end = [];
						for (var i=0;i<wcs.length;i++){
							var c = wcs[i]
							var m1 = walls[c.wall].e[c.edge][1];
							var m2 = walls[c.wall].e[c.edge][0];
							var line1 = {pt:{x:pt.x,y:pt.y},m:m1};
							var line2 = {pt:{x:walls[c.wall].e[c.edge][2][0],y:walls[c.wall].e[c.edge][2][1]},m:m2};
							var pc = collisionPoint(line1,line2);
							wall.end.push({wall:c.wall,edge:c.edge,pt:pc});
							wall.v[ii][0] = pc[0]; 
							wall.v[ii][1] = pc[1];
							wall.v = wall.v.slice(0,ii+1);
						}
						console.log("end");
						return "end";
					}
				}
			}
			else if (wall.v[ii][2] > 0){
				totald += wall.v[ii][2];
			}
		}
	}
	for (var ii=1;ii<wall.v.length-1;ii++){
		//var d = Math.pow(wall.v[ii][0]-wall.v[ii-1][0],2)+Math.pow(wall.v[ii][1]-wall.v[ii-1][1],2);
		var d = wall.v[ii][2];
		if (d <= 0){
			d = Math.pow(wall.v[ii][0]-wall.v[ii-1][0],2)+Math.pow(wall.v[ii][1]-wall.v[ii-1][1],2);
		}
		if (d > 0 && d < 16){
			
			wall.v[ii+1][2]=Math.pow(wall.v[ii-1][0]-wall.v[ii+1][0],2)+Math.pow(wall.v[ii-1][1]-wall.v[ii+1][1],2);
			
			wall.v.splice(ii,1);
			ii--;
		}
	}
	//console.log(wall.v);
}
</script>
</body>
</html>