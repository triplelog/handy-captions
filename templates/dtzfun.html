<!doctype html>
<html>
<head>
<title>DTZFun</title>
<style>
.game {
	margin: auto;
	width: 60vw;
	height: 60vh;
	left: 20vw;
	top: 20vh;
	position: absolute;
	border: 1px solid black;
}
#borderSVG {
	width: 50vh;
	height: 50vh;
	left: calc(30vw - 25vh);
	top: 5vh;
	position: absolute;
}

</style>

</head>
<body>

<div class="game">
	<svg id="borderSVG" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		
		<circle id="ball-0" cx="50" cy="50" r="3" fill="#CCF" stroke="black" stroke-width="0" />
		<circle id="ball-1" cx="50" cy="20" r="3" fill="#CCF" stroke="black" stroke-width="0" />
		<path id="wall-t" d="" fill="none" stroke="black" stroke-width="1"></path>
	</svg>
</div>

<script>

var svg = document.getElementById("borderSVG");
svg.addEventListener("pointerdown",pdown);
svg.addEventListener("pointermove",pmove);
svg.addEventListener("pointerup",pup);

walls = [{id:"wall-0",v:[[0,0],[0,100],[100,100],[90,20],[0,0]]}];
nWalls = 0;
addWall(walls[0]);

tempWall = {id:"wall-t",v:[],initial:false};
r = 3;
balls = [{id:"ball-0",x:50,y:50,a:-1,el:document.getElementById("ball-0")}];
balls.push({id:"ball-1",x:50,y:20,a:2,el:document.getElementById("ball-1")});
nBalls = 2;
let start;
let old;



function addWall(wall) {
	
	var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.id = wall.id;
	path.setAttributeNS(null,'d',pd);
	path.setAttributeNS(null,'fill',"none");
	path.setAttributeNS(null,'stroke',"red");
	path.setAttributeNS(null,'stroke-width',"1");
	svg.appendChild(path);
	nWalls+=1;
	makeEdgesOne(wall);
}
function updateWall(wall) {
	makeEdgesOne(wall);
	var path = document.getElementById(wall.id);
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function updateTemp() {
	var path = document.getElementById("wall-t");
	var pd = "M";
	for (var ii=0;ii<tempWall.v.length;ii++){
		pd += tempWall.v[ii][0]+","+tempWall.v[ii][1]+" ";
	}
	path.setAttributeNS(null,'d',pd);
}
function makeEdgesOne(wall){
	wall.e = [];
	for (var ii=1;ii<wall.v.length;ii++){
		var edge = [];
		if (wall.v[ii][0]-wall.v[ii-1][0] == 0){
			edge.push("inf");
		}
		else {
			edge.push((wall.v[ii][1]-wall.v[ii-1][1])/(wall.v[ii][0]-wall.v[ii-1][0]));
		}
		if (wall.v[ii][1]-wall.v[ii-1][1] == 0){
			edge.push("inf");
		}
		else {
			edge.push(-1*(wall.v[ii][0]-wall.v[ii-1][0])/(wall.v[ii][1]-wall.v[ii-1][1]));
		}
		edge.push(wall.v[ii-1]);
		edge.push(wall.v[ii]);
		wall.e.push(edge);
	}
}
function makeEdges(){
	for (var i=0;i<nWalls;i++){
		makeEdgesOne(walls[i]);
	}
}

function collision(pt){
	var minD = r+1;
	var c = {wall:0,edge:0,d:minD};

	for (var i=0;i<nWalls;i++){
		for (var ii=0;ii<walls[i].e.length;ii++){
			var d = r+1;
			if (pt.x < Math.min(walls[i].e[ii][2][0]-r,walls[i].e[ii][3][0]-r)) {
				//no collision
			}
			else if (pt.x > Math.max(walls[i].e[ii][2][0]+r,walls[i].e[ii][3][0]+r)) {
				//no collision
			}
			else if (pt.y < Math.min(walls[i].e[ii][2][1]-r,walls[i].e[ii][3][1]-r)) {
				//no collision
			}
			else if (pt.y > Math.max(walls[i].e[ii][2][1]+r,walls[i].e[ii][3][1]+r)) {
				//no collision
			}
			else {
				var pm = walls[i].e[ii][1];//perpendicular slope of edge
				
				if (pm == "inf"){
					d = Math.pow(walls[i].e[ii][2][1]-pt.y,2);
				}
				else if (walls[i].e[ii][0] == "inf"){
					d = Math.pow(walls[i].e[ii][2][0]-pt.x,2);
				}
				else {
					var xc = (walls[i].e[ii][2][1]-pt.y+pt.x*pm-walls[i].e[ii][2][0]*walls[i].e[ii][0])/(pm-walls[i].e[ii][0]);
					var yc = pm*(xc-pt.x)+pt.y;
					d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
				}
			}
			//console.log(pt,d);
			if (d<minD){
				minD=d;
				c.wall = i;
				c.edge = ii;
				c.d = d;
			}
		}
	}

	return c;
}

function move(timestamp) {
	if (!start){
		start = timestamp;
		old = timestamp;
		window.requestAnimationFrame(move);
		return;
	}
	const elapsed = timestamp - old;
	old = timestamp;
	for (var i=0;i<nBalls;i++){
		var x = balls[i].x+Math.cos(balls[i].a)*elapsed/40;
		var y = balls[i].y+Math.sin(balls[i].a)*elapsed/40;
		
		var c = collision({x:x,y:y});
		if (c.d <= r){
			console.log(c);
			var m = walls[c.wall].e[c.edge][0];
			var b = Math.atan(m);
			if (m == "inf"){
				b = Math.PI/2;
			}
			console.log(m);
			console.log(b);
			balls[i].a = -1*(2*Math.PI+balls[i].a-2*b);
			console.log(balls[i].a);
		}
		balls[i].el.setAttribute("cx",x);
		balls[i].el.setAttribute("cy",y);
		
		balls[i].x = x;
		balls[i].y = y;
	}
	
	
	
	if (timestamp - start < 10000) {
		window.requestAnimationFrame(move);
	}
}

window.requestAnimationFrame(move);

function updateTest(){
	walls[0].v[3]=[70,20];
	updateWall(walls[0]);
	
	var newWall = {id:"wall-1",v:[[0,100],[70,20]]};
	walls.push(newWall);
	addWall(newWall);
	
	console.log(nWalls);
	console.log(walls);
	
	start = 0;
	window.requestAnimationFrame(move);
}

isDown = false;
function pdown(evt){
	isDown = true;
	var bcr = evt.currentTarget.getBoundingClientRect();
	var x = Math.round((evt.clientX-bcr.left)/bcr.width*1000)/10;
	var y = Math.round((evt.clientY-bcr.top)/bcr.height*1000)/10;
	tempWall.v = [[x,y]];
}
function pmove(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*1000)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1000)/10;
		tempWall.v.push([x,y]);
		cleanWall(tempWall);
		if (tempWall.initial){
			updateTemp();
		}
	}
}
function pup(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*1000)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1000)/10;
		tempWall.v.push([x,y]);
		console.log(tempWall);
		isDown = false;
		
		var newWall = {id:"wall-"+nWalls,v:tempWall.v};
		walls.push(newWall);
		addWall(newWall);
		tempWall.v = [];
		tempWall.initial = false;
		
		
	}
}



function cleanWall(wall){
	if (!wall.initial){
		for (var ii=0;ii<wall.v.length;ii++){
			var pt = {x:wall.v[ii][0],y:wall.v[ii][1]};
			var c = collision(pt);
			if (c.d <= r){
				wall.v.splice(0,ii);
				wall.initial = true;
				return;
				break;
			}
		}
	}
	
	for (var ii=1;ii<wall.v.length-1;ii++){
		var d = Math.pow(wall.v[ii][0]-wall.v[ii-1][0],2)+Math.pow(wall.v[ii][1]-wall.v[ii-1][1],2);
		if (d < 2){
			wall.v.splice(ii,1);
			ii--;
		}
	}
}
</script>
</body>
</html>