<!doctype html>
<html>
<head>
<title>MagicEye.js Text Example</title>
<style>
#magiceye {
	position: absolute;
	left: 0px;
	top: 0px;
	display: inline-block;
}
	
.input {
	position: absolute;
	left: 0px;
	top: 0px;
	display: inline-block;
	width: 800px;
	height: 600px;
	opacity: 0;
}
#pixelCanvas {
	opacity: 0;
	pointer-events: none;
}

</style>

</head>
<body>
<script src="js/mymagic.js" type="text/javascript"></script>
<script src="js/TextDepthMapper.js" type="text/javascript"></script>


<canvas id="magiceye" width="800" height="600" >
</canvas>
<div class="input">

</div>
<svg style="display: none;" id="pixelSVG" viewBox="0 0 800 600" width="800" height="600" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
</svg>
<canvas id="pixelCanvas" width="800" height="600">
</canvas>
<button style="position:absolute; left:800px; top:0px;" onclick="reRender()">Again</button>

<script src='js/perlin.js'></script>
<script>
	noise.seed(Math.random());
  var colorChain = {};
  for (var i=0;i<1200;i++){
  	colorChain[i]={};
  }
  var dMap = [];
  for (var y=0;y<600;y++){
  	  dMap.push([]);
	  for (var x=0;x<800;x++){
	  	  var v = Math.abs(noise.perlin2(x/800,y/600));
	  	  v *= 2;
	  	  if (v > 1){v = 1;}
  		  dMap[y].push(v);
	  }
  }
  
  var dMap = [];
  var pMap = [];
  for (var y=0;y<600;y++){
  	  dMap.push([]);
  	  pMap.push([]);
	  for (var x=0;x<800;x++){
	  	  
  		  dMap[y].push(0);
  		  pMap[y].push(0);
	  }
  }
  for (var i=9;i<10;i++){
	  for (var y=60+i*5;y<60+i*5+300;y++){
		  for (var x=210+i*5;x<210+i*5+100;x++){
		  
			  dMap[y][x] = (i+1)/10;
		  }
	  }
  }
  
  var c=75;
  MagicEye.render({
    el: 'magiceye',
    s: 72,
    depthMap: dMap
  });


  
  function reRender() {
	
	  c++;
	  var dMap = [];
	  for (var y=0;y<600;y++){
		  dMap.push([]);
		  for (var x=0;x<800;x++){
		  
			  dMap[y].push(0);
		  }
	  }
	  for (var i=9;i<10;i++){
		  for (var y=60+i*5;y<60+i*5+c*4;y++){
			  for (var x=210+i*5;x<210+i*5+100;x++){
		  
				  dMap[y][x] = (i+1)/10;
			  }
		  }
	  }
  	MagicEye.render({
		el: 'magiceye',
		s: 72,
		depthMap: dMap,
	  });
  }


var curveWorker = new Worker('js/curveWorker.js');
var inputEl = document.querySelector('.input');
inputEl.addEventListener('pointerdown',inputDown);
inputEl.addEventListener('pointermove',inputMove);
inputEl.addEventListener('pointercancel',inputCancel);
inputEl.addEventListener('pointerup',inputUp);
var isDown = false;

curveWorker.onmessage = function(evt){
	if (evt.data.type == 'inputCurve'){
		
		//drawCurveIn(evt.data.points);
		
	}
	else if (evt.data.type == 'outputCurve'){
		drawCurveOut(evt.data.id,evt.data.pd);
		//console.log(evt.data.pd);
	}
	else if (evt.data.type == 'convexHull'){
		//drawConvexHull(evt.data.pdArray);
	}
}
var allCurves = {};
function drawCurveOut(id,pd) {
	allCurves[id]=pd;
	createDepthMap();
}
var lastPoint = [0,0];
function drawCurveIn(pt) {

	var r = 25;
	console.log(pt);
	if (Math.abs(pt[0] - lastPoint[0]) < 10 && Math.abs(pt[1] - lastPoint[1]) < 10) {
		return;
	}
		
	var m = (lastPoint[1]-pt[1])/(lastPoint[0]-pt[0]);
	var minX = Math.min(pt[0],lastPoint[0]);
	var maxX = Math.max(pt[0],lastPoint[0]);
		
	for (var i=minX;i<maxX;i++){
		var line = {};
		line.m = -1/m;
		line.x = i;
		line.y = m*(i-pt[0])+pt[1];
		var dx = Math.sqrt(Math.pow(r,2)/(1+Math.pow(line.m,2)));
		console.log(dx,line.x,line.y,line.m);
		for (var ii=Math.floor(-1*dx);ii<Math.floor(dx)+1;ii++){
			var yi = Math.floor(line.m*(ii-line.x)+line.y);
			dMap[yi][ii]=1;
			dMap[yi+1][ii]=1;
		}
	}
	

	lastPoint[0] = pt[0];
	lastPoint[1] = pt[1];
		
	const t0 = performance.now();
	MagicEye.render({
		el: 'magiceye',
		s: 72,
		rows: [yi-r,yi+r+1],
		depthMap: dMap,
	  });
	const t1 = performance.now();
	console.log(`Magic Eye took ${t1 - t0} milliseconds.`);
}



function createDepthMap(){
	
	document.getElementById('pixelSVG').innerHTML = '';
	var ids = Object.keys(allCurves);
	for (var i in ids){
		var id = ids[i];
		var path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
		//console.log(id,ids,allCurves);
		path.setAttribute('d',allCurves[id]);
		path.setAttribute('stroke','black');
		path.setAttribute('stroke-width',100);
		path.setAttribute('fill','none');
		path.id = "bg-"+id;
		document.getElementById('pixelSVG').appendChild(path);
	}
	
	var canvas = document.getElementById('pixelCanvas');
	var ctx = canvas.getContext("2d");
	let clonedSvgElement = document.getElementById("pixelSVG").cloneNode(true);
	var img2 = new Image();

	img2.onload = function() {
		//ctx.drawImage(img, 0, 0, 300, 300);
		ctx.clearRect(0,0,800,600);
		ctx.drawImage(img2, 0, 0,800,600);
		
		var imgData = ctx.getImageData(0,0,800,600).data;
		dMap = [];
		for (var y=0;y<600;y++){
		  dMap.push([]);
		  for (var x=0;x<800;x++){
		  	if (imgData[y*800*4+x*4+3] > 100){
			  dMap[y].push(1);
			}
			else {
			  dMap[y].push(0);
			}
		  }
		}
		MagicEye.render({
			el: 'magiceye',
			s: 72,
			depthMap: dMap,
		  });

	}

	img2.src = "data:image/svg+xml;base64," + window.btoa(clonedSvgElement.outerHTML);
}

function inputCancel(evt){
	if (evt.pointerType == 'pen' || evt.pointerType == 'mouse'){
		evt.preventDefault();
	}
	isDown = false;
	curveWorker.postMessage({'type':'up','x':evt.clientX,'y':evt.clientY});
}
function inputDown(evt) {
	evt.preventDefault();
	if (evt.pointerType == 'pen' || evt.pointerType == 'mouse'){
		curveWorker.postMessage({'type':'down','x':evt.clientX,'y':evt.clientY});
		isDown = true;
	}
	else {
		//document.getElementById('pointerType').innerHTML = evt.pointerType;
	}
}
function inputMove(evt) {
	evt.preventDefault();
	if (isDown && (evt.pointerType == 'pen' || evt.pointerType == 'mouse')){
		curveWorker.postMessage({'type':'move','x':evt.clientX,'y':evt.clientY});
		drawCurveIn([evt.clientX,evt.clientY]);
	}
	else {
	}
}
function inputUp(evt) {
	evt.preventDefault();
	if (isDown && (evt.pointerType == 'pen' || evt.pointerType == 'mouse')){
		isDown = false;
		
		curveWorker.postMessage({'type':'up','x':evt.clientX,'y':evt.clientY});
	}
	else {
	}
}

</script>
</body>
</html>
