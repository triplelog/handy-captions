<!doctype html>
<html>
<head>
<title>MagicEye.js Text Example</title>
<style>
#magiceye {
	position: absolute;
	left: 0px;
	top: 0px;
	display: inline-block;
}
	
.input {
	position: absolute;
	left: 0px;
	top: 0px;
	display: inline-block;
	width: 800px;
	height: 600px;
	opacity: 0;
}
#pixelCanvas {
	opacity: 0;
	pointer-events: none;
}

</style>

</head>
<body>
<script src="js/magiceyefast.js" type="text/javascript"></script>
<script src="js/TextDepthMapper.js" type="text/javascript"></script>


<canvas id="magiceye" width="800" height="600" >
</canvas>
<div class="input">

</div>
<svg style="display: none;" id="pixelSVG" viewBox="0 0 800 600" width="800" height="600" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
</svg>
<canvas id="pixelCanvas" width="800" height="600">
</canvas>
<button style="position:absolute; left:800px; top:0px;" onclick="reRender()">Again</button>

<script src='js/perlin.js'></script>
<script>
	noise.seed(Math.random());
  var colorChain = {};
  var fullColors = [];
  for (var i=0;i<600;i++){
  	colorChain[i]={};
  	var height = 600;
  	var s = 72;
  	var ym = [];
	ym.push(mulberry(i));
	ym.push(mulberry(i + height));
	var colorsFG = [];
	  for (var ii=0;ii<800;ii++){
		var c = [0,0,0,255];
		c[1] = mulberry(ym[0] + ii) % 256;
		c[2] = mulberry(ym[1] + ii) % 256;
		colorsFG.push(c);
	  }

	fullColors.push(colorsFG);
  }
  var dMap = [];
  for (var y=0;y<600;y++){
  	  dMap.push([]);
	  for (var x=0;x<800;x++){
	  	  var v = Math.abs(noise.perlin2(x/800,y/600));
	  	  v *= 2;
	  	  if (v > 1){v = 1;}
  		  dMap[y].push(v);
	  }
  }
  

  
  var dMap = [];
  var pMap = [];
  for (var y=0;y<600;y++){
  	  dMap.push([]);
  	  pMap.push([]);
	  for (var x=0;x<800;x++){
	  	  
  		  dMap[y].push(0);
  		  pMap[y].push(0);
	  }
  }
  for (var i=9;i<10;i++){
	  for (var y=60+i*5;y<60+i*5+300;y++){
		  for (var x=210+i*5;x<210+i*5+100;x++){
		  
			  dMap[y][x] = (i+1)/10;
		  }
	  }
  }
  
  
  MagicEye.render({
    el: 'magiceye',
    s: 72,
    fullColors: fullColors,
    depthMap: dMap
  });


  


var curveWorker = new Worker('js/curveWorker.js');
var inputEl = document.querySelector('.input');
inputEl.addEventListener('pointerdown',inputDown);
inputEl.addEventListener('pointermove',inputMove);
inputEl.addEventListener('pointercancel',inputCancel);
inputEl.addEventListener('pointerup',inputUp);
var isDown = false;

curveWorker.onmessage = function(evt){
	if (evt.data.type == 'inputCurve'){
		
		//drawCurveIn(evt.data.points);
		
	}
	else if (evt.data.type == 'outputCurve'){
		drawCurveOut(evt.data.id,evt.data.pd);
		//console.log(evt.data.pd);
	}
	else if (evt.data.type == 'convexHull'){
		//drawConvexHull(evt.data.pdArray);
	}
}
var allCurves = {};
function drawCurveOut(id,pd) {
	allCurves[id]=pd;
	createDepthMap();
}
var lastPoint = [-1,0];
function drawCurveIn(pt) {

	var r = 50;
	//console.log(pt);
	if (Math.abs(pt[0] - lastPoint[0]) < 10 && Math.abs(pt[1] - lastPoint[1]) < 10) {
		return;
	}
	if (lastPoint[0] == -1){
		lastPoint[0] = pt[0];
		lastPoint[1] = pt[1];
		return;
	}	
	var m = (lastPoint[1]-pt[1])/(lastPoint[0]-pt[0]);
	var minX = Math.min(pt[0],lastPoint[0]);
	var maxX = Math.max(pt[0],lastPoint[0]);
	
	var minY = -1;
	var maxY = -1;
	for (var i=minX;i<maxX;i++){
		var line = {};
		line.m = -1/m;
		line.x = i;
		line.y = m*(i-pt[0])+pt[1];
		var dx = Math.sqrt(Math.pow(r,2)/(1+Math.pow(line.m,2)));
		for (var ii=Math.floor(line.x-1*dx);ii<Math.floor(line.x+dx)+1;ii++){
			var yi = Math.floor(line.m*(ii-line.x)+line.y);
			if (yi > 600 || yi <0){
				continue;
			}
			if (ii > 800 || ii <0){
				continue;
			}
			dMap[yi][ii]=1;
			dMap[yi+1][ii]=1;
			if (yi < minY || minY == -1){
				minY = yi;
			}
			if (yi > maxY || maxY == -1){
				maxY = yi;
			}
		}
	}
	

	lastPoint[0] = pt[0];
	lastPoint[1] = pt[1];
	console.log(minY,maxY);
	const t0 = performance.now();
	MagicEye.render({
		el: 'magiceye',
		s: 72,
		rows: [minY,maxY],
		fullColors: fullColors,
		depthMap: dMap,
	  });
	const t1 = performance.now();
	console.log(`Magic Eye took ${t1 - t0} milliseconds.`);
}



function createDepthMap(){
	
	document.getElementById('pixelSVG').innerHTML = '';
	var ids = Object.keys(allCurves);
	var alphas = [0.1,0.1,0.1,0.2,0.2,0.3,0.3,0.4,0.6,0.8];
	var widths = [150,130,110,90,70,50,40,30,20,10];
	for (var i in ids){
		var id = ids[i];
		for (var ii=0;ii<10;ii++){
			var path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
			//console.log(id,ids,allCurves);
			path.setAttribute('d',allCurves[id]);
			path.setAttribute('stroke','rgba(0,0,0,'+alphas[ii]+')');
			path.setAttribute('stroke-width',widths[ii]);
			path.setAttribute('fill','none');
			path.id = "bg-"+id;
			document.getElementById('pixelSVG').appendChild(path);
		}
	}
	
	var canvas = document.getElementById('pixelCanvas');
	var ctx = canvas.getContext("2d");
	let clonedSvgElement = document.getElementById("pixelSVG").cloneNode(true);
	var img2 = new Image();

	img2.onload = function() {
		//ctx.drawImage(img, 0, 0, 300, 300);
		ctx.clearRect(0,0,800,600);
		ctx.drawImage(img2, 0, 0,800,600);
		
		var imgData = ctx.getImageData(0,0,800,600).data;
		dMap = [];
		for (var y=0;y<600;y++){
		  dMap.push([]);
		  for (var x=0;x<800;x++){
		  	
			dMap[y].push(imgData[y*800*4+x*4+3]/255);
		  }
		}
		MagicEye.render({
			el: 'magiceye',
			s: 72,
			fullColors: fullColors,
			depthMap: dMap,
		  });

	}

	img2.src = "data:image/svg+xml;base64," + window.btoa(clonedSvgElement.outerHTML);
}

function inputCancel(evt){
	if (evt.pointerType == 'pen' || evt.pointerType == 'mouse'){
		evt.preventDefault();
	}
	isDown = false;
	curveWorker.postMessage({'type':'up','x':evt.clientX,'y':evt.clientY});
}
function inputDown(evt) {
	evt.preventDefault();
	if (evt.pointerType == 'pen' || evt.pointerType == 'mouse'){
		curveWorker.postMessage({'type':'down','x':evt.clientX,'y':evt.clientY});
		lastPoint[0] = evt.clientX;
		lastPoint[1] = evt.clientY;
		isDown = true;
	}
	else {
		//document.getElementById('pointerType').innerHTML = evt.pointerType;
	}
}
function inputMove(evt) {
	evt.preventDefault();
	if (isDown && (evt.pointerType == 'pen' || evt.pointerType == 'mouse')){
		curveWorker.postMessage({'type':'move','x':evt.clientX,'y':evt.clientY});
		drawCurveIn([evt.clientX,evt.clientY]);
	}
	else {
	}
}
function inputUp(evt) {
	evt.preventDefault();
	if (isDown && (evt.pointerType == 'pen' || evt.pointerType == 'mouse')){
		isDown = false;
		
		curveWorker.postMessage({'type':'up','x':evt.clientX,'y':evt.clientY});
	}
	else {
	}
}
function mulberry(a) {
			
	  var t = a += 0x6D2B79F5;
	  t = Math.imul(t ^ t >>> 15, t | 1);
	  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	  return (t ^ t >>> 14) >>> 0;
			
}

</script>
</body>
</html>
