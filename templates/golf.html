<!doctype html>
<html>
<head>
<title>DTZFun</title>
<style>
.game {
	margin: auto;
	width: 90vw;
	height: 85vh;
	left: 5vw;
	top: 7.5vh;
	position: absolute;
	border: 1px solid black;
	touch-action: none;
	--w: 120;
}
img {
	width: 160vh;
	height: 80vh;
	left: calc(45vw - 160vh / 2);
	top: 2.5vh;
	position: absolute;
}
#borderSVG {
	width: calc(var(--w) / 120 * 80vh);
	height: 80vh;
	left: calc(45vw - calc(var(--w) / 120 * 80vh) / 2);
	top: 2.5vh;
	position: absolute;
}

</style>

</head>
<body>
<button onclick="showInfo()">Show</button>
<button onclick="nextRound()">Next</button>
<button onclick="startMove()">Start</button>
<button onclick="clearMove()">Clear</button>

<div class="game">

	<svg id="borderSVG" viewBox="-10 -10 120 120" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

		<path id="wall" d="" fill="white" stroke="black" stroke-width="1"></path>
		
	</svg>
</div>

<script src="js/postfix.js"></script>
<script>

winpct = 70;
var maxTime = 1000000;

var svg = document.getElementById("borderSVG");
svg.addEventListener("pointerdown",pdown);
svg.addEventListener("pointermove",pmove);
svg.addEventListener("pointerup",pup);

/*var outlineWall = {{ bigwall | dump | safe }};
var allHoles = {{ allHoles | dump | safe }};
var ball = {x:{{ ball.x }},y:{{ ball.y }},d:5,a:1,s:20,el:null};
var ballStart = {x:{{ ball.x }},y:{{ ball.y }}};
var hole = {x:{{ hole.x }},y:{{ hole.y }} };*/

var outlineWall;
var allHoles = {{ allHoles | dump | safe }};
var ball;
var ballStart;
var hole;
var width;

var cdId = 0;
var wall;
var isDown = false;
var shot = {el:null,coords:[]};
var actual = {el:null,coords:[],pd:""};
var lastShot = {el:null,coords:[],pd:""};
var start = false;
var r = 2;
var old;
var showAll = false;
var lastCollision = false;
var showChange = 0;
resetGame();

function resetGame(){
	outlineWall = allHoles[cdId].bigwall;
	width = allHoles[cdId].width;
	document.getElementById('borderSVG').style.width = ((width+20) / 120 * 80) +'vh';
	document.getElementById('borderSVG').style.left = 'calc(45vw - calc('+(width+20)+' / 120 * 80vh) / 2)';
	document.getElementById('borderSVG').setAttributeNS(null,'viewBox',"-10 -10 "+(width+20)+" 120");
	ball = {x:allHoles[cdId].ball.x,y:allHoles[cdId].ball.y,d:5,a:1,s:20,el:null};
	ballStart = {x:allHoles[cdId].ball.x,y:allHoles[cdId].ball.y};
	hole = {x:allHoles[cdId].hole.x,y:allHoles[cdId].hole.y };
	wall = {v:outlineWall};
	
	svg.innerHTML = '<path id="wall" d="" fill="white" stroke="black" stroke-width="1"></path>';
	
	addWall();
	svg.innerHTML += '<path id="shot" d="" fill="none" stroke="gray" stroke-width="1"></path>';
	shot.el = document.getElementById("shot");
	svg.innerHTML += '<path id="actual" d="" fill="none" stroke="blue" stroke-width="1"></path>';
	actual.el = document.getElementById("actual");
	svg.innerHTML += '<path id="lastShot" d="" fill="none" stroke="gray" stroke-width="0.25"></path>';
	lastShot.el = document.getElementById("lastShot");
	svg.innerHTML += '<circle id="hole" cx="'+hole.x+'" cy="'+hole.y+'" r="3" fill="none" stroke="green" stroke-width="1"></circle>';

	svg.innerHTML += '<circle id="ball" cx="'+ball.x+'" cy="'+ball.y+'" r="2" fill="blue" stroke="none" stroke-width="0"></circle>';
	ball.el = document.getElementById("ball");
	
}

function clearMove(){
	var pd = actual.pd;
	
	wall = {v:outlineWall};
	isDown = false;
	shot = {el:null,coords:[]};
	actual = {el:null,coords:[],pd:""};
	lastShot = {el:null,coords:[],pd:""};
	start = false;
	r = 2;
	old;
	lastCollision = false;
	
	resetGame();
	lastShot.el = document.getElementById("lastShot");
	
	lastShot.el.setAttributeNS(null,'d',pd);
}

function addWall() {
	
	var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	var pd = "M";
	for (var ii=0;ii<wall.v.length;ii++){
		pd += wall.v[ii][0]+","+wall.v[ii][1]+" ";
	}
	path.id = "outline";
	path.setAttributeNS(null,'d',pd);
	path.setAttributeNS(null,'fill',"white");
	path.setAttributeNS(null,'stroke',"red");
	path.setAttributeNS(null,'stroke-width',"1");
	var wt = document.getElementById("wall");
	svg.insertBefore(path,wt);

	wall.e = [];
	for (var ii=1;ii<wall.v.length;ii++){
		var edge = [];
		if (wall.v[ii][0]-wall.v[ii-1][0] == 0){
			edge.push("inf");
		}
		else {
			edge.push((wall.v[ii][1]-wall.v[ii-1][1])/(wall.v[ii][0]-wall.v[ii-1][0]));
		}
		if (wall.v[ii][1]-wall.v[ii-1][1] == 0){
			edge.push("inf");
		}
		else {
			edge.push(-1*(wall.v[ii][0]-wall.v[ii-1][0])/(wall.v[ii][1]-wall.v[ii-1][1]));
		}
		edge.push(wall.v[ii-1]);
		edge.push(wall.v[ii]);
		wall.e.push(edge);
	}
}


function startMove() {
	start = 0;
	showChange = 0;
	actual.el = document.getElementById("actual");
	actual.coords = [[ball.x,ball.y]];
	actual.pd = "M"+ball.x+","+ball.y+" ";
	actual.el.setAttributeNS(null,'d',actual.pd);
	window.requestAnimationFrame(move);
}

function dPtEdge(pt,edge){
	var pm = edge[1];//perpendicular slope of edge
	var d;
	if (pm == "inf"){
		d = Math.pow(edge[2][1]-pt.y,2);
	}
	else if (edge[0] == "inf"){
		d = Math.pow(edge[2][0]-pt.x,2);
	}
	else {
		var xc = (edge[2][1]-pt.y+pt.x*pm-edge[2][0]*edge[0])/(pm-edge[0]);
		var yc = pm*(xc-pt.x)+pt.y;
		d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
	}
	return d;
}
function collisionOne(pt,c){
	for (var ii=0;ii<wall.e.length;ii++){
		var d = r*r+1;
		var corner = false;
		var maxX = wall.e[ii][2][0];
		var minX = wall.e[ii][3][0];
		var xFlip = false;
		var yFlip = false;
		var maxY = wall.e[ii][2][1];
		var minY = wall.e[ii][3][1];
		if (wall.e[ii][3][0]>wall.e[ii][2][0]){
			maxX = wall.e[ii][3][0];
			minX = wall.e[ii][2][0];
			xFlip = true;
		}
		if (wall.e[ii][3][1]>wall.e[ii][2][1]){
			maxY = wall.e[ii][3][1];
			minY = wall.e[ii][2][1];
			yFlip = true;
		}
		if (pt.x < minX-r) {
			//no collision
		}
		else if (pt.x > maxX+r) {
			//no collision
		}
		else if (pt.y < minY-r) {
			//no collision
		}
		else if (pt.y > maxY+r) {
			//no collision
		}
		else {
			var pm = wall.e[ii][1];//perpendicular slope of edge
			
			if (pm == "inf"){//wall is horizontal
				d = Math.pow(wall.e[ii][2][1]-pt.y,2);
				if (pt.x > maxX){
					if (xFlip){
						corner = ii;
					}
					else {
						corner = ii-1;
					}
					
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else if (pt.x < minX){
					if (xFlip){
						corner = ii-1;
					}
					else {
						corner = ii;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
			}
			else if (wall.e[ii][0] == "inf"){
				
				d = Math.pow(wall.e[ii][2][0]-pt.x,2);
				if (pt.y > maxY){
					if (yFlip){
						corner = ii;
					}
					else {
						corner = ii-1;
					}
					
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else if (pt.y < minY){
					if (yFlip){
						corner = ii-1;
					}
					else {
						corner = ii;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				
			}
			else {
				var xc = (wall.e[ii][2][1]-pt.y+pt.x*pm-wall.e[ii][2][0]*wall.e[ii][0])/(pm-wall.e[ii][0]);
				var yc = pm*(xc-pt.x)+pt.y;
				
				if (xc > maxX){
					if (xFlip){
						corner = ii;
					}
					else {
						corner = ii-1;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else if (xc < minX){
					if (xFlip){
						corner = ii-1;
					}
					else {
						corner = ii;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else if (yc > maxY){
					if (yFlip){
						corner = ii;
					}
					else {
						corner = ii-1;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else if (yc < minY){
					if (yFlip){
						corner = ii-1;
					}
					else {
						corner = ii;
					}
					d = Math.pow(pt.x-wall.v[corner][0],2)+ Math.pow(pt.y-wall.v[corner][1],2);
				}
				else {
					d = Math.pow(pt.x-xc,2)+ Math.pow(pt.y-yc,2);
				}
			}
		}
		//console.log(pt,d);
		if (d<c.d){
			c.wall = 0;
			c.edge = ii;
			c.d = d;
			c.corner = corner;
		}
	}
	return c;
}

function collision(pt){

	
	var c = {wall:0,edge:0,d:r*r+1,corner:false};
	c = collisionOne(pt,c);

	return c;
}


function move(timestamp) {

	if (!start){
		start = timestamp;
		old = timestamp;
		showChange = timestamp;
		window.requestAnimationFrame(move);
		return;
	}
	const elapsed = timestamp - old;
	old = timestamp;

	var x = ball.x+Math.cos(ball.a)*elapsed*ball.s/1000;
	var y = ball.y+Math.sin(ball.a)*elapsed*ball.s/1000;
	var c = collision({x:x,y:y});
	if (c.d <= r*r){
		var m = wall.e[c.edge][0];//slope of line we hit
		var thisCollision = "e"+c.edge;
		var skipCol = false;
		console.log(c);
		if (c.corner || c.corner === 0){
			thisCollision = "v"+c.corner;
			if (thisCollision == lastCollision){
				skipCol = true;
			}
			else {
				lastCollision = thisCollision;
			}
			console.log(c.corner,wall.v);
			var cx = wall.v[c.corner][0];
			var cy = wall.v[c.corner][1];
			console.log(c.corner);
			var mm = (y-cy)/(x-cx);
			
			if (x-cx == 0){
				m = 0;
			}
			else if (y-cy == 0){
				m = "inf";
			}
			else {
				m = -1/mm;//slope of corner line
			}
			console.log(m);
		}
		else {
			if (thisCollision == lastCollision){
				skipCol = true;
			}
			else {
				lastCollision = thisCollision;
			}
		}
		if (showAll){
			console.log(m,Math.atan(m),ball.a);
		}
		if (!skipCol){
			var b;
			if (m == "inf"){
				b = Math.PI/2;
				ball.a = -1*(2*Math.PI+ball.a-2*b);
			}
			else {
				m = m*(width + 20)/120;
				b = Math.atan(m);
				console.log(ball.a,b,m);
				ball.a = -1*(2*Math.PI+ball.a-2*b);
				console.log(ball.a,b,m);
				var d = dPtEdge({x:x,y:y},wall.e[c.edge]);
				var dd = dPtEdge({x:x+Math.cos(ball.a)*elapsed/40,y:y+Math.sin(ball.a)*elapsed/40},wall.e[c.edge]);
				if (dd < d){
					console.log("closer later?");
					ball.a = Math.PI/4+ball.a;
				}
			}
			if (showAll){
				console.log(x,y,ball.x,ball.y,m,Math.atan(m),ball.a);
			}
			if (ball.a > 2*Math.PI){
				ball.a -= 2*Math.PI;
			}
			else if (ball.a < -2*Math.PI){
				ball.a += 2*Math.PI;
			}
		}
		
		
	}
	
	
	
	
	ball.x = x;
	ball.y = y;

	actual.coords.push([ball.x,ball.y]);
	actual.pd += ball.x+","+ball.y+" ";
	actual.el.setAttributeNS(null,'d',actual.pd);
	
	if (timestamp - showChange > 100){
		ball.el.setAttribute("cx",x);
		ball.el.setAttribute("cy",y);
		showChange = timestamp;
	}
	
	
	
	if (timestamp - start < ball.d*1000) {
		window.requestAnimationFrame(move);
	}
	else{
		ball.el.setAttribute("cx",x);
		ball.el.setAttribute("cy",y);
		ball.x = ballStart.x;
		ball.y = ballStart.y;
	}
}



function area(polygon) {
    let total = 0;
    for (let i = 0; i < polygon.length; i++) {
        const addX = polygon[i][0];
        const addY = polygon[i === polygon.length - 1 ? 0 : i + 1][1];
        const subX = polygon[i === polygon.length - 1 ? 0 : i + 1][0];
        const subY = polygon[i][1];
        total += (addX * addY * 0.5) - (subX * subY * 0.5);
    }
    return Math.abs(total);
}

function nextRound(){
	level++;
	resetGame(level);
}
function showInfo(){
	showAll = true;
	start = 0;
	maxTime = 1000;
}
function updateTest(){

	start = 0;
	window.requestAnimationFrame(move);
}


function drawShot(){
	var pd = "M";
	for (var i=0;i<shot.coords.length;i++){
		pd += shot.coords[i].x+","+shot.coords[i].y+" ";
	}
	shot.el.setAttributeNS(null,'d',pd);
}
function takeShot(){
	var el = document.getElementById("shot");
	var d = el.getTotalLength();
	var origin = shot.coords[0];
	console.log(d);
	ball.d = d / ball.s;
	var sum_x = 0;
	var sum_y = 0;
	var angle = ball.a;
	var minD = r*r;
	var isC = false;
	for (var i=0;i<100;i++){
		var loc = el.getPointAtLength(d*i/100);
		loc.x -= origin.x;
		loc.y -= origin.y;
		sum_y += loc.y;
		sum_x += loc.x;
		var m = sum_y/sum_x;
		angle = Math.atan(m);
		if (sum_x < 0){
			angle += Math.PI;
		}
		var x = origin.x+Math.cos(angle)*(d*i/100);
		var y = origin.y+Math.sin(angle)*(d*i/100);
		var pt = {x:x,y:y};
		var c = collision(pt);
		if (c.d < 0.5 || (c.d > minD + r/2 && isC) ){
			break;
		}
		else if (c.d < minD){
			minD = c.d;
			isC = true;
		}
	}
	
	console.log(m,angle);
	ball.a = angle;
}
function pdown(evt){
	isDown = true;
	var bcr = evt.currentTarget.getBoundingClientRect();
	var x = Math.round((evt.clientX-bcr.left)/bcr.width*( width + 20 )*10 - 100)/10;
	var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
	shot.coords=[{x:x,y:y}];
	shot.el = document.getElementById("shot");
}

function pmove(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*( width + 20 )*10 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		shot.coords.push({x:x,y:y});
		drawShot();
	}
}
function pup(evt){
	if (isDown){
		var bcr = evt.currentTarget.getBoundingClientRect();
		var x = Math.round((evt.clientX-bcr.left)/bcr.width*( width + 20 )*10 - 100)/10;
		var y = Math.round((evt.clientY-bcr.top)/bcr.height*1200 - 100)/10;
		shot.coords.push({x:x,y:y});
		isDown = false;
		takeShot();
	}
}

function collisionPoint(line1,line2){
	if (line1.m == "inf"){
		line1.m = 1000;
	}
	if (line2.m == "inf"){
		line2.m = 1000;
	}
	if (line1.m == line2.m){
		return [line1.pt.x,line1.pt.y];
	}
	var xc = (line2.pt.y-line1.pt.y+line1.pt.x*line1.m-line2.pt.x*line2.m)/(line1.m-line2.m);
	var yc = line1.m*(xc-line1.pt.x)+line1.pt.y;
	return [xc,yc];
}

</script>
</body>
</html>